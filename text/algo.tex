\chapter{Algorithm for NAC-coloring search}%
\label{chapter:alg}

\begin{chapterabstract}

	As shown before it is NP-complete to decide if a graph has a NAC-coloring,
	therefore we cannot hope for an algorithm that can solve this problem in polynomial time.
	The trivial idea how to search for NAC-colorings is to
	try all the \( \red \)-\( \blue \)-edge colorings
	and check in polynomial time if a coloring given is a NAC-coloring.
	In this chapter we propose multiple optimizations to the naive approach
	and an algorithm that significantly outperforms naive approach in general case.

\end{chapterabstract}

The goal of this section is to propose algorithms to find some or all NAC-colorings of a given graph.
After recalling the solution used in \flexrilog{},
we describe an improvement of the idea of \trcon{} components in \Cref{sec:NACvalid}
and checking whether a coloring is a NAC-coloring in \Cref{sec:small_cycles}.
In \Cref{sec:combining} we sketch the idea of algorithms that
exploit combining NAC-colorings of subgraphs.
We propose heuristics for decomposing into subgraphs and merging strategies
in \Cref{sec:decomposition,sec:merging} respectively.
Although the proposed approaches are written so that all NAC-colorings are generated,
the existence of a NAC-coloring can be checked easily by stopping after finding a first one.

This chapter is based on our previous work in~\cite{my_paper},
here we describe the approaches used more in detail
and also describe other approaches that do not work as well the approaches also
shown in the paper. We evaluate performance of the algorithm in \Cref{chapter:benchmarks}.

\section{Naive approach}

A naive approach to list all NAC-colorings is to consider
all $2^{|E(G)|}$ surjective edge colorings of graph $G$ by red and blue
and check each of them in polynomial time using \Cref{lemma:is_nac_coloring}.
We call this check \IsNACColoring{}$(G, E_r, E_b)$.
To remind the reader, the idea is quite simple
--- first we create subgraphs \( G[E_\red], G[E_\blue] \).
If there is w.l.o.g.\ \( \blue \) edge \( \{u, v\} \)
and \( \{u, v\} \) share the same connected component in \( G[E_\red] \),
an almost cycle is formed from a \( \red \) \( u \)-\( v \)-path in \( G[E_\red] \)
and the \( \blue \) edge \( \{u, v\} \).

This algorithm we call \Naive{} runs in \( O(2^{|E(G)|}) \) time.
It can be sped up dramatically by considering sets of edges instead of individual edges.
For some sets of edges, we can easily see that all the edges in the set need to share
the same color in every NAC-coloring.
Now we can color the whole sets at once
and therefore reduce the time complexity to \( O(2^{c}) \)
where \( c \) is the number of described sets.
One example of such set are \trcon{} components
as defined in~\Cref{def:triangle_connected_component}.
In the following section we extend upon the idea of \trcon{} components
to reduce the search space even further.

Another simple but important observation is that the whole search space \( O(2^{c}) \)
does not need to be traversed as a NAC-coloring with colors swapped is again a NAC-coloring.
Therefore, we fix color of one set of edges and also generate NAC-colorings with colors swapped.
This cuts our runtime in half to \( O(2^{c-1}) \).
% TODO cite https://www.youtube.com/watch?v=FZ4qeJly1g0

The algorithm implemented in \flexrilog{}
considers only colorings such that \trcon{} components are monochromatic
and also ignores NAC-colorings with colors swapped.

\section{NAC-valid relations}%
\label{sec:NACvalid}

While the idea of \trcon{} components is that 3-cycles are monochromatic,
there are other cases when two edges have to have the same color,
which can further reduce the search space.
Namely, we aim to find a partition of the edge set such that each part is necessarily monochromatic
in every NAC-coloring and the number of parts is as small as possible.

\begin{definition}[NAC-valid~\cite{my_paper}]%
	\label[definition]{def:NACvalid}
	%
	An equivalence relation $\sim$ on the edge set
	of a graph $G$ is called \emph{NAC-valid}
	if for every NAC-coloring $\delta$ of $G$ it holds that
	$\forall e_1, e_2 \in E(G) :
		e_1 \sim e_2 \Rightarrow \delta (e_{1}) = \delta (e_{2})$.
	An equivalence class of a NAC-valid relation is called a \emph{monochromatic class}.
	%
\end{definition}
%
With that, we also define terms used with monochromatic classes:
%
\begin{itemize}
	\item The \emph{vertices} of a monochromatic class $M$
	      are the vertices of the subgraph $G[M]$.
	\item We call two distinct monochromatic classes \( M_1, M_2 \) \emph{neighboring},
	      if they share at least one common vertex.
	      % if the intersection of the vertices of \( M_1, M_2 \) is non-empty.
	\item The \emph{degree} of a monochromatic class \( M \) is the number of
	      monochromatic classes that are neighbors of \( M \).
\end{itemize}
%
\begin{observation}%
	\label[observation]{observ:monochromatic_classes_graph}
	Monochromatic classes behave like a graph
	where monochromatic classes are vertices and there is an edge incident to
	two monochromatic classes if they are neighboring.
\end{observation}
%

Clearly, the relation inducing \trcon{} components is NAC-valid.
The following lemma describes a way how to construct a new NAC-valid relation from another one
with possibly less monochromatic classes.

\begin{lemma}[\cite{my_paper}]%
	\label[lemma]{lemma:two_edges_and_component}
	%
	Let $\sim$ be a NAC-valid relation on $G$ and
	$\sim^\prime$ be a relation on $E(G)$ given by
	$e_{1} \sim^\prime e_{2}$ if and only if
	$e_{1} \sim e_{2}$ or there exists
	a cycle $C$ in $G$ such that $e_{1}, e_{2}$
	are edges in $C$
	and all other edges are in the same monochromatic class of $\sim$.
	Then the reflexive-transitive closure of $\sim^\prime$ is NAC-valid.
\end{lemma}
%
\begin{proof}
	%
	The condition in \Cref{def:NACvalid} is preserved under taking reflexive-transitive closure,
	so it suffices to check it only for $\sim^\prime$: if $e_1$ and $e_2$ had different colors in some NAC-coloring,
	then $C$ would be an almost cycle since $C - \{e_1,e_2\}$ is monochromatic as the relation $\sim$ is NAC-valid.
	%
\end{proof}

Note that various situations can occur:
$e_1$ or $e_2$ is in the same a monochromatic class of~$\sim$ as the rest of $C$,
or neither of them is, see \Cref{fig:two_edges_and_component}.
If each monochromatic class of $\sim$ induces a connected subgraph,
then the edges $e_1$ and $e_2$ can be supposed to be incident,
but this is not the case in general.
For instance one could introduce a NAC-valid relation such that both triangles in a 3-prism subgraph
are in the same monochromatic class, since they have the same color in all NAC-colorings of the 3-prism.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}[scale=2]
		\node[vertex] (0) at (0, 0) {};
		\node[vertex] (1) at (1, 0.5) {};
		\node[vertex] (2) at (2, 0) {};
		\node[vertex] (3) at (0.5, 0.866) {};
		\node[vertex] (4) at (1.5, 0.866) {};
		\draw[redge] (0)edge(1) (1)edge(2) (0)edge(3) (1)edge(3) (1)edge(4) (2)edge(4) (3)edge(4)  ;
		\draw[edge]  (0)edge(2)  ;
	\end{tikzpicture}
	\qquad
	\begin{tikzpicture}[scale=2]
		\node[vertex] (0) at (0, 0) {};
		\node[vertex] (1) at (1, 0.5) {};
		\node[vertex] (2) at (2, 0) {};
		\node[vertex] (3) at (0.5, 0.866) {};
		\node[vertex] (4) at (1.5, 0.866) {};
		\node[vertex,label={north:$v$}] (5) at (1, 0) {};
		\draw[redge] (0)edge(1) (1)edge(2) (0)edge(3) (1)edge(3) (1)edge(4) (2)edge(4) (3)edge(4)  ;
		\draw[edge]  (0)edge(5) (2)edge(5)  ;
	\end{tikzpicture}
	\caption[Monochromatic classes advantage.]{
		An edge with adjacent vertices in a monochromatic class (left) and
		two edges with adjacent vertices in a monochromatic class (right).}%
	\label{fig:two_edges_and_component}
\end{figure}

Notice that application of \Cref{lemma:two_edges_and_component} corresponds
to merging the monochromatic classes of $e_1$ and $e_2$.
We propose to use the following NAC-valid relation:
we start with the \trcon{} components and then apply the following two steps
as long as there is some change:
%
\begin{enumerate}
	\item If there is an edge \( \{u, v\} \) such that $u$ and $v$ are vertices of
	      the same monochromatic class $M$, then merge $M$ with the monochromatic class of \( \{u, v\} \).
	\item If there are edges \( \{u, v\} \) and \( \{v, w\} \) such that $u$ and $w$ are vertices of
	      the same monochromatic class, then merge the monochromatic classes of \( \{u, v\} \) and \( \{v, w\} \).
\end{enumerate}
%
Every \trcon{} component induces a connected subgraph and also the two operations preserve
the fact that each monochromatic class induces a connected subgraph.
Hence, the resulting partition indeed forms monochromatic classes
of a NAC-valid relation by \Cref{lemma:two_edges_and_component}.
The construction can be done in polynomial time
and implemented efficiently using a Union-find data structure
as presented in the pseudocode of \Cref{alg:create_monochromatic classes}.
\todo[inline]{Consider moving \Cref{alg:create_monochromatic classes} to attachments}

\begin{algorithm}
	\caption{Create Monochromatic classes~\cite{my_paper}}%
	\label{alg:create_monochromatic classes}
	\begin{algorithmic}[1]
		\Require{} $G$

		\Ensure{} $P \gets ()$
		\Comment{} list of monochromatic classes

		\State{} $U \gets \Call{CreateUnionFind}{E(G)}$
		\Comment{} create Union-find data structure

		\ForAll{$e_{1},e_{2},e_{3} \in \Call{FindAllTriangles}{G}$}
		\State{} $U \gets \Call{Join}{U, e_{1}, e_{2}, e_{3}}$
		\EndFor{}

		\State{} $U^\prime \gets \emptyset$
		\While{$U^\prime \not= U$}
		\State{} $U^\prime \gets U$
		\Comment{} as long as changes happen

		\State{} $\lambda : V(G) \to \mathcal{P}(E(G))$
		\Comment{} monochromatic classes a vertex is member of,
		\State{}
		\Comment{} classes are represented by a single edge, defaults to $\emptyset$

		\ForAll{$uv \in E(G)$}
		\State{} $e^\prime \gets \Call{Find}{U, uv}$
		\State{} $\lambda(u) \gets \lambda(u) \cup \{e^\prime\}$
		\State{} $\lambda(v) \gets \lambda(v) \cup \{e^\prime\}$
		\EndFor{}

		\ForAll{$v \in V(G)$}
		\If{$\exists u, w \in N(v) : \lambda(u) \cap \lambda(w) \not= \emptyset$}
		\State{} $U \gets \Call{Join}{U, vu, vw}$
		\Comment{} edges are over a same component
		\EndIf{}
		\EndFor{}
		\EndWhile{}

		\State{} $P \gets \Call{Sets}{U}$

	\end{algorithmic}
\end{algorithm}

With these improvements the complexity of the naive algorithm can be often
reduced even further.

\section{Small cycles}%
\label{sec:small_cycles}

The check \IsNACColoring{} can be quite computationally expensive
considering it is called for every possible coloring,
even though it can be implemented as simple breadth-first-search.
An optimization we use is to keep a list of shorter cycles in the graph and
check if they are almost monochromatic cycles before doing the full check.
We call this improved \Naive{} algorithm \NaiveCycles{}.

The check for a single cycle can be done in linear time
in the number of monochromatic classes using bitwise arithmetic.
One cycle $C$ can reject up to $\frac{1}{|E(C)|}$ colorings,
which can be significant for small cycles.

There are often multiple and many cycles of different lengths in the graph
and for the algorithm, only a subset of them can be chosen.
If we choose too few, performance is left on the table, if too much,
we spend too much time checking the masks while saving little
by avoiding \IsNACColoring{} checks.
The number of cycles should also grow with the number of edges,
resp.\ monochromatic classes.
As stated above, smaller cycles are preferred.

Following that, we propose the following strategy.
Given a graph $G$ and $k,\ell\in \mathbb{N}$,
we adopt the idea to monochromatic classes as follows:
for every monochromatic class $M$ in $G$,
we consider all edges $\{u, v\} \in M$ such that there is a path from $u$ to $v$
in $G - M$ that uses at most $k$ monochromatic classes.
We pick up to $l$ cycles constructed from $uv$ with the corresponding
path with the least number of used monochromatic classes.
In our implementation, we take $k=4$ and $l=2$ cycles for every monochromatic class.

\section{Combining NAC-colorings of subgraphs}%
\label{sec:combining}

In our algorithm called \Subgraphs{} a graph is decomposed into subgraphs so that
the NAC-colorings of the graph can be obtained from the NAC-colorings of the subgraphs.
We introduce notation for this process of combining NAC-colorings of suitable subgraphs.

\begin{definition}[\cite{my_paper}]
	%
	Let $G$ be a graph with subgraphs $G_1, \dots, G_k$
	s.\ t.\ $\bigcup_{i=1}^k E(G_i) =E(G)$.
	For $1\leq i \leq k$, let $\delta^{i}_{\red}$ and
	$\delta^{i}_{\blue}$ be the monochromatic colorings of $G_i$.
	The set
	\[ \Bigl\{
		\text{surjective }\delta : E(G) \to \{\blue, \red\}
		\mid\forall i : \delta |_{E(G_i)} \in
		\nac{G_i} \cup \{\delta^{i}_{\blue}, \delta^{i}_{\red}\}
		\Bigr\}
	\]
	is called the \emph{NAC-product} of $G_1, \dots, G_k$ and denoted by $\CP(G_1, \dots, G_k)$.
	%
\end{definition}

Since the restriction of a NAC-coloring of a graph
to its subgraph is either a NAC-coloring or monochromatic,
we have $\nac{G_{1} \cup G_{2}} \subseteq \CP(G_{1}, G_{2})$.
If $G_1, \dots, G_k$ are the connected components of $G$,
then $\nac{G} = \CP(G_1,\ldots, G_k)$.
Since every cycle is contained in a single
block\footnote{A \emph{block} is a bridge or a maximal 2-connected subgraph.}
of a graph, we have that $\nac{G} = \CP(G_1,\ldots, G_k)$
for $G_1,\ldots, G_k$ being the blocks of $G$.

In order to design a faster algorithm for searching for all NAC-colorings,
we exploit the fact that for edge-disjoint graphs $G_1$ and $G_2$,
it is straightforward to construct $\CP(G_{1}, G_{2})$ once we know $\nac{G_1}$ and $\nac{G_2}$.
Then, we can get $\nac{G_{1} \cup G_{2}}$ by applying \IsNACColoring{}
to each coloring in $\CP(G_{1}, G_{2})$, see also \Cref{alg:coloring_product}.
This can significantly reduce the number of \IsNACColoring{} calls
compared to testing all red-blue-colorings of $G_{1} \cup G_{2}$.
To apply the idea on a graph $G$, we:
%
\begin{enumerate}
	\item decompose $G$ into pairwise edge-disjoint subgraphs $G_1, \ldots, G_\ell$, and
	\item compute the NAC-product $\CP(G_1, \dots, G_\ell)$ using $\nac{G_1}, \ldots, \nac{G_\ell}$
	      and filter it to get $\nac{G}$.
\end{enumerate}
%
It is also important to note that in case the merged subgraphs
have no vertices in common, we get the whole NAC-product.
No filtering is needed in such case.
%
In the following two subsections we discuss possible heuristics
for these two phases.

\begin{algorithm}
	\caption{NAC-product with filtering}%
	\label{alg:coloring_product}
	\begin{algorithmic}[1]
		\Require{} $G_1, G_2$
		\Comment{} subgraphs
		\Require{} $N_1, N_2$
		\Comment{} NAC-colorings of the subgraphs (pairs of sets of edges)

		\Ensure{} $G$
		\Comment{} merged subgraphs
		\Ensure{} $S \gets \emptyset$
		\Comment{} the NAC-colorings of $G$

		\State{} $G = (V(G_1)\cup V(G_2), E(G_1) \cup E(G_2))$

		\State{} $N_1 \gets N_1 \cup \{(E(G_1), \emptyset), (\emptyset, E(G_1))\}$
		\Comment{} the subgraphs can also be monochromatic
		\State{} $N_2 \gets N_2 \cup \{(E(G_2), \emptyset), (\emptyset, E(G_2))\}$

		\ForAll{$(E_{r_{1}}, E_{b_{1}}) \in N_1$}
		\ForAll{$(E_{r_{2}}, E_{b_{2}}) \in N_2$}
		\State{} $E_r \gets E_{r_{1}} \cup E_{r_{2}}$
		\State{} $E_b \gets E_{b_{1}} \cup E_{b_{2}}$
		\If{$\Call{IsNACColoring}{G, E_r, E_b}$}
		% \Comment{} cycles check can be also used here
		\State{} $S \gets S \cup \{(E_r, E_b)\}$
		\EndIf{}
		\EndFor{}
		\EndFor{}
	\end{algorithmic}
\end{algorithm}

\subsection{Subgraph decomposition}%
\label{sec:decomposition}

On the input, we assume the list of monochromatic classes
and an integer $k\geq 1$, and we output a list of subgraphs
such that each has at most $k$ monochromatic classes.
We describe some heuristics how to split a graph into edge disjoint subgraphs.
Here in contrast with~\cite{my_paper} we also discuss heuristics
that did not perform well.

\subsubsection{\None{}}

The strategy with the least overhead costs is to take the chunks of $k$ consecutive
monochromatic classes in the vertex input list (heuristic \None{}).
Some synthetically generated graphs are formed in such a way
that \None{} ends up performing as good as the other strategies,
this strategy usually fails when the vertex input list is shuffled.

Our general goal for the following strategies
is to maximize the number of suitable cycles in each
subgraph as cycles may form almost cycles and those help us
to reduce the search space.

\subsubsection{\Neighbors{}}

We start with a heuristic that we call \Neighbors{},
its pseudocode is in \Cref{alg:neighbors}.
The algorithm aims to mimic breadth-first-search
behavior while respecting monochromatic classes.
The goal is to find monochromatic classes that are close together.
Let $P$ be the list on monochromatic classes,
for simplicity we assume that $k$ divides $|P|$.
We will gradually divide the monochromatic classes into bags,
the output are the subgraphs induced by the monochromatic classes in each bag.

We start with $\frac{|P|}{k}$ empty bags
and all vertices of the graph labelled $open$.
First we add a random of the remaining monochromatic classes to a bag.
All the vertices of the monochromatic classes in the bag are denoted by $used$.
We take all $open$ vertices that are neighbors of the vertices in $used$ and assign
them a score. A vertex $best$ with the highest score is chosen.
The monochromatic classes corresponding to edges connecting the vertex $best$
with vertices in $used$ are then added to the bag while not exceeding its size.
The $used$ set is updated, and the algorithm continues until the bag is full.
If $open$ is empty, this iteration of the search also ends.
A new bag is chosen, and we repeat the process.

The first strategy \Neighbors{} takes as the score the number of
neighboring vertices of a vertex in the $used$ set.
The other strategy \NeighborsDegree{} is based
on the first and adds another rule ---
if the number of neighbors match, the vertex with lower degree is chosen.

\begin{algorithm}
	\caption{Heuristic \Neighbors}%
	\label{alg:neighbors}
	\begin{algorithmic}[1]

		\Require{} $G$
		\Comment{} a graph
		\Require{} $P$
		\Comment{} monochromatic classes of $G$
		\Require{} $k$, $b \gets |P|/k$
		\Comment{} target size of bags, the number of bags

		\Ensure{} $O \gets (B_1, \ldots, B_b)$
		\Comment{} bags with monochromatic classes

		\While{$P \ne \emptyset$}
		\State{} $p \gets p \in P$
		\State{} $P \gets P \setminus \{p\}$
		\Comment{} random monochromatic class

		\State{} $B \gets \underset{B_i \in O}{\arg\min} |B_i|$
		\Comment{} the most empty bag

		\State{} $used \gets \{{v \in M} \mid {M \in B } \}$
		\Comment{} vertices already used by this bag
		\State{} $open \gets  \{w \in N(u) \mid u \in used\} \setminus used $
		\Comment{} neighbors, candidates for addition

		\While{$|open| > 0 \land |B| < k$}

		\State{} $best \gets \underset{u \in open}{\arg\max}|used \cap N(u)|$
		\Comment{} vertices with the largest neighborhood

		\For{$n \in N(best) \land |B| < k$}
		\State{} $p \gets p \in P$ such that $\{best, n\} \in p$
		\State{} $P \gets P \setminus \{p\}$

		\State{} $B \gets B \cup \{p\}$

		\State{} $used \gets used \cup \{v \mid {v \in p} \}$
		\State{} $open \gets  \{w \in N(u) \mid u \in used\} \setminus used $
		\EndFor{}
		\EndWhile{}
		\EndWhile{}
	\end{algorithmic}
\end{algorithm}

\subsubsection{\CyclesMatchChunks{}}

Monochromatic classes are first ordered descending by their degree.
Then cycles are found for each monochromatic class with the same procedure
as described in \Cref{sec:small_cycles}.
The algorithm, modified version of the breadth-first-search, goes as follows:
when a stage starts, we take a component with the highest degree
that has not been marked as used yet and add it to a queue.
While the queue is non-empty, we pop the first monochromatic class,
add it the result list and mark it as used.
Then we traverse all the cycles (that we obtained before)
corresponding to the component
and add monochromatic components from the cycles to the queue.
The stage ends when the queue is empty or when \( k \) monochromatic classes
were marked as used. The whole process is repeated until
all monochromatic classes are marked as used.

\todo[inline]{Pseudocode, maybe?}

\subsubsection{\KernighanLin{}, \Cuts{}}

Kernighan-Lin algorithm~\cite{kernighan_lin} proposes a heuristic based algorithm
for partitioning a graph into two parts. It tires to minimize the edge cut between
the parts by iteratively swapping pairs of vertices from the parts.

As noted in~\Cref{observ:monochromatic_classes_graph},
monochromatic classes can be converted into a graph.
In this strategy \KernighanLin{},
Kernighan-Lin algorithm is recursively run to split the graph into parts till
parts smaller than \( k \) are reached.
We hope that smaller edge cuts will preserve more cycles among
the monochromatic classes, that often also represent cycles in the real graph.

We also tried approach \Cuts{}, where Kernighan-Lin algorithm is replaced by
more classical flow based edge cuts to split graph into parts.
With that, we loose the guarantee that the parts in recursive step
are similar in size. The resulting components should still remain similar.

Other strategies based on
sorting monochromatic components by their degree
or breadth-first-search were also tried,
but with no meaningful results.

\subsubsection{Smart split}%
\label{sec:smart_split}

We already talked how important is that the subgraphs have something in common
while we perform the filtering of the coloring product. We also talked about the order of
subgraphs and how do merging strategies interact with them.
Goal of the following algorithm is to create and order subgraphs in a way that they usually
share property that reduces the output size while running
the filtering of the coloring product.

The strategies for subgraph creation are generic --- they accept a graph and
the list of sizes as input and output subgraphs. We exploit this property here. We use
these strategies to divide the graph given in half by giving it appropriate
sizes (the sum of first half of subgraph sizes and the sum of the rest).
Then we split the subgraphs further until we reach desired graph sizes.
We order the created subgraphs in the tree traversal order.
By doing that we hope to ensure that most of the neighboring subgraph pairs share
some vertices and therefore more cycles appear in the merged subgraph.

Also note that \Cref{alg:smart_split} has compatible interface with
all the subgraph creation strategies and therefore can be easily added.

\begin{algorithm}
	\caption{Smart Split}%
	\label{alg:smart_split}
	\begin{algorithmic}[1]
		\Require{} $G$
		\Comment{} Subgraph to work on
		\Require{} $P$
		\Comment{} Monochromatic classes of the subgraph $G$
		\Require{} $S$, $s \gets |S|$
		\Comment{} List of the sizes of subgraphs and their number

		\Ensure{} $O \gets ()$
		\Comment{} List of ordered vertices

		\If{$s \le 2$}
		\State{} $O \gets \Call{MergeStrategy}{G, P, S}$
		\State{}
		\Return{}
		\EndIf{}

		\State{} $S_1, S_2 \gets S[:\lfloor\frac{s}{2}\rfloor], S[\lfloor\frac{s}{2}\rfloor:]$
		\State{} $P \gets \Call{SubgraphStrategy}{G, P, (\sum S_{1}, \sum S_{2})}$

		\State{} $P_1 \gets P[:(\sum S_1)]$
		\State{} $P_2 \gets P[(\sum S_1):]$
		\State{} $G_1 \gets \Call{InducedSubgraphOnEdges}{G, \bigcup P_1}$
		\State{} $G_2 \gets \Call{InducedSubgraphOnEdges}{G, \bigcup P_2}$

		\State{} $O_1 \gets \Call{SmartSplit}{G_1, P_1, S_1}$
		\State{} $O_2 \gets \Call{SmartSplit}{G_2, P_2, S_2}$
		\State{} $O \gets O_{1}.O_{2}$
	\end{algorithmic}
\end{algorithm}


\subsection{Subgraph merging}%
\label{sec:merging}

After constructing the list of edge-disjoint subgraphs,
we compute all the NAC-colorings for each of them using
the naive algorithm with monochromatic classes
and improved check on cycles.
Then the results need to be merged to obtain the NAC-colorings of the original graph
using the NAC-product.

Since checking every coloring in the NAC-product is a costly operation,
we try to minimize the work that has to be done.
The complexity of the task grows with the size of
the merged subgraphs (as \IsNACColoring{} depends on the size of the graph checked)
and also with the number of NAC-colorings found in each subgraph
(which can grow exponentially).

We describe multiple merging strategies.
As before, we extend on the list we presented in~\cite{my_paper}.
The first approach \MergeLinear{} is
to take the sequence of subgraphs and merge them one by one.
We merge the first and the second subgraph, then we merge this result with the
third one and so on. We have tried also tree-like approach, i.e., to merge consecutive pairs
and then recursively again, but the performance was worse.

Another approach called \SharedVertices{} always merges the two subgraphs that
have the most vertices in common with the goal
to create as many new cycles as possible.

Next approach called \Log{} tries to merge subgraphs in a tree like manner.
Consider we have an order list of subgraphs,
for simplicity let its size be \( 2^c \) for some \( c \in \N \).
Now, the list is split into pairs of subgraphs and NAC-colorings
of the subgraphs in pairs are merged. With that, a new list is created.
The continues until we have the original graph and all its NAC-colorings.
Note, that the approach makes little sense if~\Cref{alg:smart_split}
is not also enabled.

We consider the number of monochromatic components
that induces a given subgraph as its size.
One heuristic is that runtime can be reduced
when first small subgraphs are merged with large subgraphs
rather than large graphs with large subgraphs, as merging large graphs is expensive.
This is what \MinMax{} strategy does.
First smallest subgraph is merged with the largest one,
then second smallest with the second largest and so on.
A new list is created, and the same procedure is run on repeatedly.

Following strategy is called \PromissingCycles{}.
The strategy tries to guess which subgraphs
have the most potential almost cycles when joined.
For each pair of subgraphs we find cycles in joined subgraph using
the same routine as in \Cref{sec:small_cycles}.
A joined graph with the maximal number of cycles is chosen,
otherwise we score as follows:
%
\begin{itemize}
	\item If subgraphs share a vertex, the score grows.
	\item Smaller joined graphs get higher priority.
	\item Subgraphs with more common vertices get higher priority.
\end{itemize}
%

All the previous merging strategies did not employ the number of NAC-colorings
of individual subgraphs in merging decisions.
That is on purpose as we do not know the number of NAC-colorings in advance.
With that, if only a single NAC-coloring is needed,
in our implementation we can use lazy iterators that
find a NAC-coloring of a subgraph and wait till another coloring is requested.
If all the NAC-colorings are desired or if we expect the graph to have no NAC-coloring,
all NAC-colorings of subgraphs need to be found anyway.
In such cases we can employ heuristics that take advantage of such additional knowledge.

Our preferred strategy of this kind is called \Score{}
In each iteration a score is computed for each pair of subgraphs in the current list.
For subgraphs \( G_1, G_2 \) the score is computed by formula
\( \nnac{G_1} \cdot \nnac{G_2} \cdot \text{sizeof}(G_1 \cup G_2) \).
The score approximates the amount of work needed,
therefore the pair with the lowest score is chosen.

We also tried approaches based on dynamic programming and recursive optimization.
Unfortunately, these approached do not scale well to larger instances.

\section{Polynomial optimizations}%
\label{sec:polynomial_optimizations}
\todo[inline]{Write the section}
% stable cut observation
% to many edges
% to few edges -> stable cut
% minimally rigid if not certificate is needed
