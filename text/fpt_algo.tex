\chapter{FPT Algorithm for NAC-coloring counting}%
\label{chapter:fpt}

\begin{chapterabstract}

	It can be easily shown that the NAC-coloring existence as an NP-complete
	problem can be parametrized by treewidth by using \( \text{MSO}_2 \) logic.
	In this chapter, we present an algorithm that can obtain
	the number of NAC-coloring of a graph in \({k}^{O(k)} 2^{O(k^2)} n^{O(1)}\) time,
	where \(k\) stands for the treewidth of the graph.

\end{chapterabstract}

\section{Treewidth}

We use notation as used in~\cite{book_parametrized_algorithms}.
Treewidth is one of many graph parametrizations like
pathwidth, cliquewidth, maximal degree and many others.
These approaches are used to somehow exploit graphs structure
and provide algorithms with possibly significantly lower time complexity
then algorithms considering general graphs only.
For a list of other common parametrization approaches,
we recommend~\cite{tree_width_comparision_other_classes}.
Using these approaches, many NP-complete problems can be solved
in a time polynomial in \( n \) where \( n = |V| \)
for many graph classes that have such a bounded structural property.
To name a few such problems:
\textsc{Vertex Cover}, \textsc{Dominating Set}, \textsc{Longest Path}, \dots

%
\begin{definition}[FPT alorithm~\cite{book_parametrized_algorithms}]
	Algorithms with running time \( f(k)\cdot n^c \)
	where \( k \) is a parameter dependent on the instance
	and for a constant \( c \),
	are called \emph{fixed-parameter tractable (FPT) algorithms}.
\end{definition}
%
In parametrized algorithms, \( k \) stands for different parameters
representing some form on internal graph structure as noted before.

For many problems it is quite simple to find a fast solution on trees.
Often a dynamic programming approach is needed for that.
%
One of the most popular and simple approaches
is the use of treewidth and tree decomposition.
The metric tries to show how similar a graph is to a tree.
%
The usual goal of algorithms is to develop a dynamic programming algorithm
that exploits the tree-likeness of a graph.

%
\begin{definition}[Tree decomposition~\cite{book_parametrized_algorithms}]
	A \emph{tree decomposition} of a graph \( G \) is
	a pair \( (T, {\{X_t\}}_{t \in V ( T )}) \)
	where \( T \) is decomposition tree and every node \( t \)
	is assigned a bag \( X_t \subseteq V(G) \) such that the following hold:
	%
	\begin{enumerate}
		\item \( \bigcup_{t \in V(T)} X_t = V(G) \),
		      i.e., each vertex is in at least one bag.
		\item For every \( \{u,v\} \in E(G) \), there exists
		      a node \( t \in T \) such that both \( u, v \in X_t \).
		\item For every \( u \in V(G) \),
		      the set \( T_u = \{t \in V(T) \mid u \in X_t\} \)
		      induces a connected subtree of \( T \).
	\end{enumerate}
\end{definition}
%
\begin{definition}[Treewidth~\cite{book_parametrized_algorithms}]
	The \emph{width} of a tree decomposition given by pair
	\( (T, {\{X_t\}}_{t \in V ( T )}) \)
	equals to \( \max_{t\in V(T)} |X_t| - 1 \).
	The \emph{treewidth} of a graph \( G \) is the minimum such width
	across all tree decompositions of \( G \).
\end{definition}
%
The width is decreased by one, so the treewidth of a tree is one.

Throughout the chapter we use term \emph{vertex} for vertices of \( G \)
and \emph{node} for nodes of \( T \).
We also shorten \( t \in V(T) \) to \( t \in T \).

We follow with a lemma that is important for all the related
dynamic programming approaches running on tree decompositions.
%
\begin{definition}[Vertex subset border~\cite{book_parametrized_algorithms}]
	Let \( A \subseteq V(G) \). Then the \emph{border} of \( A \) denoted by \( \delta(A) \)
	is the set of vertices
	\( \{u \in A \mid \exists v \in V(G) \setminus A : \{u, v\} \in E(G) \} \).
\end{definition}
%
\begin{lemma}[\cite{book_parametrized_algorithms}]
	Let \( (T, {\{X_t\}}_{t \in V ( T )}) \)
	be a tree decomposition of a graph \( G \)
	and let \( \{a, b\} \in E(T) \).
	Then \( T - \{a, b\} \) consists of two connected components \( T_a, T_b \).
	%
	Let \( A = \bigcup_{t \in T_a} X_t \) and \( B = \bigcup_{t \in T_b} X_t \).
	Then \( \delta(A), \delta(B) \subseteq X_a \cap X_b \).
\end{lemma}
%
The lemma also reads as:
``\( X_a \cap X_b \) is a vertex cut in \( G \) and \( A, B \)
are distinct connected components''.

For a graph, many different tree decompositions can be obtained.
There may for example be multiple nodes with same bags or just a single node.
We also have no guarantee how two neighboring bags differ --- how many vertices changed.
Therefore, we want to define \emph{a nice tree decomposition} where neighboring nodes
represent some useful change between two bags.
First, we want our nice tree to be a rooted tree,
let \( r \in T \) be the root node.
%
\begin{definition}[Nice tree decomposition~\cite{book_parametrized_algorithms}]
	A tree decomposition
	\( (T, {\{X_t\}}_{t \in V ( T )}) \) rooted at \( r \in T \)
	is \emph{nice} if the following conditions are satisfied:
	%
	\begin{itemize}
		\item \( X_r = \emptyset \) and \( X_l = \emptyset \) for every \LeafNode{} \( l \in T \).
		\item Every non-leaf node is one of the following types:
		      \begin{itemize}
			      \item \IntroduceVertexNode{} --- a node \( t \) with one child \( t' \)
			            such that \( X_t = X_{t'} \cup \{v\} \) where \( v \not\in X_{t'} \).
			            We say that \( v \) is \emph{introduced} by \( t \).
			      \item \ForgetVertexNode{} --- a node \( t \) with one child \( t' \)
			            such that \( X_t = X_{t'} \setminus \{v\} \) where \( v \in X_{t'} \).
			            We say that \( v \) is \emph{forgotten} by \( t \).
			      \item \JoinNode --- a node \( t \) with two children \( t_1, t_2 \)
			            such that \( X_t = X_1 = X_2 \).
		      \end{itemize}
	\end{itemize}
	%
	We denote the root node by \RootNode{} and leaf nodes by \LeafNode{}.
	Vertex bags of these nodes are empty.
\end{definition}
%
\begin{figure}[ht]
	\begin{center}
		\includegraphics[width=0.80\textwidth]{./assets/nice_tree_decomposition.png}
	\end{center}
	\caption[Nice tree decomposition]{An example of a nice tree decomposition with width three~\cite{nice_tree_decomposition_img}.
		In (A) you can see the decomposed graph, in (B) the nice tree decomposition
		with \LeafNode{}s on the right and the \RootNode{} on the left.
	}%
	% \label{fig:nice_tree_decomposition}
\end{figure}
\todo[inline]{Do in Tikz or SVG, maybe}

Note that a vertex \( v \in V(G) \) can be introduced multiple times,
but forgotten only once.
By \( V_t, t \in T \), we denote the set of vertices introduced by \( t \)
and all its child nodes.

\begin{lemma}[\cite{book_parametrized_algorithms}]
	Any tree decomposition of width at most \( k \) can be converted to
	a nice tree decomposition of width at most \( k \)
	in time \( O(k^2 \cdot \max(|V(T)|, |V(G)|)) \).
	The nice decomposition tree has at most \( O(k|V(G)|) \) nodes.
\end{lemma}

The problem of finding treewidth is NP-complete~\cite{tree_width_np_complete}.
Luckily, the problem is studied a lot and
there exist efficient approximation algorithms~\cite{tree_width_approximation}.
We consider nice tree decompositions as given along with a graph
and do not consider runtime required to find it.

In \IntroduceVertexNode{}, all the edges connecting it
to vertices in \( X_{t'} \) are usually considered while processing \( t \).
%
For some problems it is beneficial to divide this operation further.
First a vertex is added with no edges using a \IntroduceVertexNode{}
and later all the edges corresponding to the vertex are added using new \IntroduceEdgeNode{}s.
We define an edge bag \( Y_t, t \in T \) similarly as vertex bags \( X_t \).
%
Let \( t' \) be a direct ancestor of \( t \).
For \IntroduceVertexNode{}, we define \( Y_t = Y_{t'} \).
For \ForgetVertexNode{} forgetting vertex \( v \),
we define \( Y_t = Y_{t'} \setminus \{ e \in E(G) \mid v \in e\} \).
For a \JoinNode{}, the condition \( Y_t = Y_{t_1} = Y_{t_2} \) must hold.
%
By \( E_t, t \in T \), we denote the set of edges introduced by \( t \)
and all its child nodes.
By \( G_t, t \in T \), we mean the graph \( G_t = (V_t, E_t) \).
%
\begin{definition}[\IntroduceEdgeNode{}~\cite{book_parametrized_algorithms}]
	A node \( t \), labeled with an edge \( e = \{u, v\} \in E(G) \)
	such that \( u, v \in X_t \) and with exactly one child \( t' \)
	such that \( X_t = X_{t'} \), \( Y_t = Y_{t'} \cup \{e\} \).
	We say that \( e \) is \emph{introduced} by \( t \).
\end{definition}
%
Each edge can be introduced at most once.

For edge \( \{u, v\} \) we can transform a nice tree decomposition \( T \)
by adding \IntroduceEdgeNode{}s \( t \) above \IntroduceVertexNode{}s of \( u, v \)
and bellow \ForgetVertexNode{}s of \( u, v \) in \( T \).

%
\begin{lemma}
	\label[lemma]{lemma:join_node_no_edges}
	%
	For each \JoinNode{} \( t \in T \) with children \( t_1, t_2 \)
	it holds that \( Y_t = \emptyset \).
\end{lemma}
%
\begin{proof}
	Assume there is an edge \( e = \{u, v\} \in Y_t \).
	As each edge can be added and removed exactly once
	and in a \JoinNode{} \( t \) both bags need to be the same,
	edge \( e \) must have been introduced in both \( t_1 \) and \( t_2 \).
\end{proof}
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Monadic second-order logic}

Monadic second-order logic~(\MSO{}) on graphs is a logical system based on
well known predicate logic.
In the world of parametrized algorithms,
it often comes handy --- if we are able to represent a problem using~\MSO{},
then there exists an FPT algorithm parametrized by treewidth
that can solve the problem~\cite{tree_width_mso}.

\subsection{Introduction to \( \text{MSO}_2 \)}

In the following paragraphs we paraphrase and simplify formal definition
from~\cite{book_parametrized_algorithms}.
We presume that reader is already familiar with first-order predicate logic.
Second-order predicate logic as an extension of first-order predicate logic,
that adds option to quantify over predicates.

\MSO{}~is an realization of second-order predicate logic.
\todo[inline]{TODO Convert to footnote, currently, it raises exceptions in NVim}
\emph{
	% \footnote{
	We need second-order logic as quantification over subsets of vertices or edges
	corresponds to quantification over predicates defining the subsets.
	Without this requirement, we could talk
	about the monadic first-order logic \( \text{MSO}_1 \).
}

Formulas can be formed from
variables, constants, predicates,
boolean operations \( \lnot, \land, \lor, \Rightarrow, \Leftrightarrow \)
and quantifiers \( \forall, \exists \).
Complex formulas are created recursively from atomic formulas
by applying schema related to each operation or quantifier.
This process is the same as in the first-order predicate logic.

Formulas of \MSO{} can use four types of variables:
for single vertices, single edges, subsets of vertices, and subsets of edges.
An evaluation function is a mapping from variables to truth assignments.
By \( u^G \) we denote evaluation of variable \( u \) in graph \( G \)
for some model \( \mathcal{G} \) (a tuple of evaluation function and \( G \)).
In \MSO{} to form atomic formulas, we allow only following base predicates:
%
\begin{itemize}
	\item For \( u \) representing a vertex (edge) variable
	      and \( X \) is a vertex (edge) subset,
	      we can write formula \( u \in X \).
	      For \( G \) the formula is true if \( u^G \in X^G \) is true.
	\item Let \( u \) be a vertex variable and \( e \) be an edge variable,
	      then we can write formula \( \inc (u, e) \).
	      For \( G \) the formula is true if \( u^G \) is an endpoint of \( e^G \).
	\item For any two variables \( u, v \) of the same type we can write \( u = v \).
	      For \( G \) the formula is true if \( u^G = v^G \).
\end{itemize}
%
We also allow simplifications like \( \ne, \not\in \).
As obvious from types of variables, we can quantify over vertices, edges,
subsets of vertices and subsets of edges.

It is beneficial to define auxiliary predicates to simplify our work.
We follow by some examples and simplifications taken from~\cite{book_parametrized_algorithms}.
First we show predicate \( \text{adj} \) represents if two vertices are adjacent.
%
\begin{align*}
	\text{adj}(u, v) \coloneqq (u \ne v) \land (\exists e \in E : \inc (u, e) \land \inc (v, e))
\end{align*}
%
For a graph \( G = (V, E) \) we can represent connectivity of its induced subgraph
on vertices \( X \subseteq V \) with the following predicate~\cite{book_parametrized_algorithms}.
%
\begin{align*}
	\text{connected}(X) \coloneqq \, &
	\forall Y \subseteq V : \Big(
	(
	\exists u \in X : u \in Y \land
	\exists v \in X : v \not\in Y
	)
	\\ &
	\Rightarrow
	(
	\exists u, v \in X : \text{adj}(u, v) \land u \in Y \land v \not\in Y
	)\Big).
\end{align*}
%
Notice that we used our previously defined predicate as an alias.
For \( X = V \) the formula would read as:
``For each separation of a graph, there exists an edge connecting both partitions''.

\subsection{Relation to treewidth}

In the following, for a formula \( \phi \) by \( \|\phi\| \)
we denote the length of the encoding of \( \phi \) as a string.
%
\begin{theorem}[Courcelle's theorem,~\cite{tree_width_mso,book_parametrized_algorithms}]%
	\label{theorem:courcelles_theorem}%
	Assume that \( \phi \) is a formula of \MSO{} and
	\( G \) is an \( n \)-vertex graph equipped
	with evaluation of all the free variables of \( \phi \).
	Suppose, moreover, that a tree decomposition of \( G \) of width \( k \) is provided.
	Then there exists an algorithm that verifies whether \( \phi \)
	is satisfied in \( G \) in time \( f (\|\phi\|, k) \cdot n \),
	for some computable function \( f \).
\end{theorem}
%
If we are given an optimal tree decomposition, or we manage to find good enough
approximation, we know that we can decide any formula in \MSO{} in a time
polynomial in \( n \), we are given no guaranties about the complexity of \( f \).

\subsection{Expressing NAC-colorings using \( \text{MSO}_2 \)}

In this section we present results from our previous paper~\cite{my_paper}.
We start by defining other auxiliary predicates:
%
\begin{itemize}
	\item For \( V \) all vertices and \( E \) subset of edges we define predicate
	      %
	      \begin{align*}
		      \text{deg2}(E) \coloneqq \,
		       & \forall e \in E : \forall v \in V : \inc (v, e) \Rightarrow \Big( \exists e' \in E : \\
		       & \big( \inc (v, e') \land e \ne e' \land (\forall e^{\prime\prime} \in E :
				      \lnot \inc (v, e^{\prime\prime}) \lor e^{\prime\prime} \not\in \{e, e'\}) \big) \Big).
	      \end{align*}
	      %
	      The predicate says that all vertices incident to edges in \( E \) have degree two.
	      %
	\item For \( V \) subset of vertices and \( E \) subset of edges we define predicate
	      %
	      \begin{align*}
		      \text{incident}(V, E) \coloneqq \,
		       & (\forall v \in V : \exists e \in E : \inc (v, e))                                                 \\
		       & \land (\forall e \in E : \exists v_1, v_2 \in V : v_1 \ne v_2 \land \inc (v_1) \land \inc (v_2)).
	      \end{align*}
	      %
	      The predicate says that \( V \) are vertices of the subgraph induced by \( E \)
	      and that \( E \) are edges of the subgraph induced by \( V \).
	      %
	\item For \( E \) subset of edges we define predicate
	      %
	      \begin{align*}
		      \text{cycle}(E) \coloneqq \,
		      \big( \exists X \subseteq V : \text{incident}(X, E) \land \text{connected}(X) \big)
		      \land \text{deg2}(E).
	      \end{align*}
	      %
	      The predicate says that edges \( E \) form a cycle.
	      %
	\item For \( E_1, E_2 \) subsets of edges we define predicate
	      %
	      \begin{align*}
		      \text{partition}(E_1, E_2) \coloneqq \, & (\exists e_1, e_2 \in E : e_1 \in E_1 \land e_2 \in E_2 )    \\
		                                              & \land (\forall e \in E : e \in E_1 \lor e \in E_2 )          \\
		                                              & \land (\forall e \in E : e \not\in E_1 \lor e \not\in E_2 ).
	      \end{align*}
	      %
	      The formula reads as: ``Both the partitions are not empty,
	      and each edge is in exactly one of the partitions''.
	\item For \( C, E_\red, E_\blue \) subsets of edges we define predicate
	      %
	      \begin{align*}
		      \text{NACcond}(C, E_\red, E_\blue) \coloneqq \,
		       & C \subseteq E_\red \lor C \subseteq E_\red
		      \\
		       & \lor (\exists e_1, e_2, e_3, e_4 \in E :
		      e_1 \ne e_2 \land e_3 \ne e_4
		      \\
		       & \qquad \land e_1, e_2 \in E_\red \land e_3, e_4 \in E_\blue ).
	      \end{align*}
	      %
	      The predicate says that the cycles \( C \) is not an almost cycle.
	      %
\end{itemize}
%

With the predicates ready, we can proceed approach to the theorem.
%
\begin{theorem}[\cite{my_paper}]
	The problem of existence of a NAC-coloring is fixed parameter
	tractable when parametrized by treewidth.
\end{theorem}
%
\begin{proof}
	We can express the NAC-coloring problem
	as a formula \( \phi \) in \MSO{} as follows:
	%
	\begin{align*}
		\exists E_\red, E_\blue \subseteq E : \,
		 & \text{partition}(E_\red, E_\blue)                                                                 \\
		 & \land \big(\forall C \subseteq E : \text{cycle}(C) \land \text{NACcond}(C, E_\red, E_\blue) \big)
		.
	\end{align*}
	%
	By \Cref{theorem:courcelles_theorem},
	there exists an FPT algorithm parametrized by treewidth
	that can resolve \( \phi \) and therefore resolve the question whenever a graph has a NAC-coloring.
\end{proof}
%
The proof shows us that there exists such an algorithm,
but it does not give us explicit steps to follow
(even tough they can be deduced from the original proof of \Cref{theorem:courcelles_theorem}).
Still, the complexity guaranties of the algorithm are not very clear.
In the following section we define our
own FPT algorithm that solves the NAC-coloring problem
while not relying on~\MSO{}.

\section{FPT algorithm}

In this section, we first introduce the core idea of
our FPT algorithm for NAC-coloring counting,
define a cache function,
show and prove the correct value of the cache function for each node in a tree decomposition
and determine the complexity of the algorithm.
Lastly, we propose optimizations to the algorithm by empowering monochromatic components
and by using other tricks.

\subsection{The algorithm}

Our algorithm is slightly similar to Steiner tree search algorithm
as described in~\cite{book_parametrized_algorithms} as both the problems require connectivity
among vertex partitions. Unlike in the Steiner tree search algorithm,
our state space is even larger and all the operations work significantly differently.

Before we start, we define some terms that come useful later.
When we talk about a component, we mean a connected component.
%
\begin{definition}[Bridge, Neighboring components]
	For a graph \( G \) with a NAC-coloring \( \delta \)
	and two distinct components
	with vertices \( U \) and \( V \)
	in \( G[\Ered] \), resp. \( G[\Eblue] \),
	a \emph{bridge} is an edge \( e = \{u, v\} \in E(G) \)
	such that \( u \in U \land v \in V \).
	%
	The components are \emph{neighboring} if there exists
	a bridge for these two components.
\end{definition}
%

First we want to build the intuition for the upcoming operations.
Let us have a graph \( G \) and all the NAC-colorings of the graph \( \nac{G} \).
Let us add an edge \( e = \{u, v\}, e \not\in E(G) \) to form graph~\( G' \).
We want to obtain \( \nac{G'} \) based on \( \NAC (G) \).
%
Let us have \( \delta \in \nac{G} \),
we want to extend it to \( \delta' \) where w.l.o.g.\ \( \delta'(e) = \blue \).
Coloring \( \delta' \) is a NAC-coloring unless an almost cycle is formed in \( G' \).
In that case one of the following cases must be true:
%
\begin{itemize}
	\item Both vertices \( u, v \) are in the same component in \( G[\Ered] \).
	      An almost cycle is formed
	      from \( \red \) \( u \)-\( v \)-path in the component
	      and edge \( e \) with \( \blue \) color.
	\item Vertices \( u, v \) lay in different components in \( G[\Eblue] \)
	      and there is a \( \red \) bridge on the components.
	      An almost cycle is formed from \( \blue \) paths in each component,
	      the \( \red \) bridge and \( \blue \) edge \( e \).
\end{itemize}
%
In all other cases an almost cycle cannot be formed by adding \( \blue \) colored edge \( e \).
Note that a vertex cannot be in multiple component for the given color
as this fact would mean that both the components are not maximal.

To create \( \nac{G'} \), we extend the colorings
in \( \nac{G} \cup \{ \delta_\red \} \), where \( \delta_\red \)
colors all the edges in \( G \) with \( \red \) color.
We do likewise for the case when \( e \) is colored \( \red \).
Then we keep only the colorings that did not form an almost cycle.

In the following sections
we work with a nice tree decomposition \( T \) with treewidth \( k \)
of a graph \( G \).
%
We define an \emph{almost NAC-coloring}
as a \( \red \)-\( \blue \) edge coloring such that there
are no almost cycles formed. The conditions are the same as for NAC-coloring
except that the surjectivity criterion is dropped.
We use almost NAC-coloring for the rest of the section.
Later when output is read in a \RootNode{},
we switch back from almost NAC-colorings to NAC-colorings.

\emph{Dynamic programming} is a well-known technique for solving problems
where the problem can be subdivided into smaller sub-problems.
Usually, some base cases are solved trivially and then a sub-problem
is solved based on the solution of its smaller sub-problems.
Often it is a case, that a smaller sub-problem would be solved multiple times
as it is a part of multiple larger sub-problems.
Its first result is therefore cached and reused reducing the total running time significantly.
There are many popular dynamic programming algorithms
like \textsc{Edit Distance}, \textsc{Matrix Chain Multiplication} or \textsc{Longest Common Subsequence}.

We define a state space \( S \) of \emph{states}
that will be used by our cache in our dynamic programming algorithm.
We denote all partitions of a set \( X \) by \( \mathcal{F}(X) \).
Note that it always holds that \( \emptyset \in \mathcal{F}(X) \).

%
\begin{definition}[State space]
	Let \( t \in T \) be a node in the nice tree decomposition tree and
	\Xt{} be a bag of vertices.
	% where with \( l \le k+1 \) vertices
	%
	A state is formed by a tuple \( s = (P_\red, R_\red, P_\blue, R_\blue) \)
	where \( P_\red \in \mathcal{F}(X)\), resp. \( P_\blue \), is a partition of \Xt{}
	and \( R_\red\), resp. \(R_\blue \), is a symmetric irreflexive relation
	on parts in \( P_\red\), resp. \(P_\blue \).
	%
	For \( t \), all such states on \Xt{} form the \emph{state space} \( S_t \).
\end{definition}
%
Partitions \( P_\red, P_\blue \) represent vertices
that are in the same component induced by edges of a specified color
in the \( G_t \) for some coloring.
Two parts are \emph{neighboring} if their corresponding components are neighboring.
When we talk about \emph{\( \red \) half of a state},
we mean \( P_\red \) and \( R_\red \),
analogically for \( \blue \).
%
A state represents sort of a projection of almost NAC-colorings of \( G_t \)
grouped by common behavior on \( X_t \) --- vertices of \( X_t \) are in the same components.
%
Relations \( R_\red, R_\blue \) represent
whenever the components (or parts) are neighboring.
This plays major role for detecting almost cycles.
%
For some \( t \in T \),
an almost NAC-coloring \( \delta \) of \( G_t \)
is \emph{consistent} with a state \( s_t = (P_\red, R_\red, P_\blue, R_\blue), s_t \in \in S_t \)
if \( \red \) and \( \blue \) components of \( \delta \) form \( P_\red \) and \( P_\blue \)
when intersected with \( X_t \) and
there are bridges between the components if and only if
the components are neighboring \( R_\red \) and \( R_\blue \).
Multiple almost NAC-coloring can be consistent with a single state.
%
Note that the state space is somewhat large, we evaluate the size in~\Cref{thm:fpt_algo}.

For the following definitions, lemmas, proofs and theorems, let us fix
a nice tree decomposition \( T \) of a graph \( G \).
%
\begin{definition}[Cache function]
	Let us have a mapping \( c: \mathcal{S} \to \N_0 \)
	where \( \mathcal{S} = \{ (t,s): t \in T, s \in S_t \} \).
	If it holds that \( c(t, s) \) maps to the number of almost NAC-colorings of \( G_t \)
	consistent with \( s \) for all \( t \in T \),
	we call \( c \) a \emph{cache function}.
	By \emph{cache entry} we denote a pair \( (t, s) \in \mathcal{S} \).
	By \emph{cache value} we devote the value \( c(t, s) \) for a cache entry \( (t, s) \).
\end{definition}
%
\begin{observation}
	For each almost NAC-coloring \( \delta \) on \( G_t \)
	there is single state \( s \in S_t \) consistent with it.
	It holds that \( |\nac{G_t}| + 2 = \sum_{s \in S_t} c(t, s) \).
\end{observation}

In the following sections we show how to construct a cache function \( c \)
based on values of child nodes in \( T \).
We make sure that the precondition that \( c(t, s) \) represents the number of almost NAC-colorings
consistent with \( s \in S_t \) for any \( t \in T  \) always hold.
We work with invalid states that produce almost cycles and
get zero cache entry value as they cannot represent any almost NAC-coloring.
We prove the algorithm's correctness by induction.
The base case is for \LeafNode{}s, for other nodes we split the reasoning for cases where
there is or is not at least one edge in \( G_t \).
Next few lemmas work as follows: for a state \( s \in S_t \)
we derive states \( s' \in S_{t'} \) from whose cache entry \( (t, s) \)
can be computed based on already computed values of \( c \).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Leaf node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lemma}%
	\label[lemma]{lemma:fpt_leaf_node}
	%
	Let us have a \LeafNode{} \( t \in T \).
	It holds that \( c[t, s] \coloneqq 0 \) for all \( s \in S_t \).
\end{lemma}
%
\begin{proof}
	There are no edges as \( X_t \) has no edges.
	By definition of the cache function \( c \) must hold \( 0 \)
	for each \LeafNode{} state.
\end{proof}
%
Note that for a \LeafNode{} \( t \in T \),
the only state in \( S_t \) is \( (\emptyset, \emptyset, \emptyset, \emptyset) \)
as \( X_t = \emptyset \).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduce Vertex Node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lemma}%
	\label[lemma]{lemma:fpt_introduce_vertex_node}
	%
	Let an \IntroduceVertexNode{} \( t \in T \) be
	the only parent of \( t'\) in \( T \) and let \( s \in S_t \).
	Let \( v \) be the only vertex in \( X_t \setminus X_{t'} \).
	%
	If there is no edge in the graph \( G_t \), then \( c[t, s] \coloneqq 0 \).
	%
	Otherwise, we define cache function value for
	\( s=(P_\red, R_\red, P_\blue, R_\blue) \)
	for \( a \in \{\red, \blue\} \) as:
	%
	\begin{align*}
		c[t, s] & \coloneqq
		\begin{cases}
			0,                                                                                 & \text{if } \exists a : \{v\} \not\in P_a,                    \\
			0,                                                                                 & \text{if } \exists a \exists p \in P_a : (\{v\}, p) \in R_a, \\
			c[t', (P_\red \setminus \{\{v\}\}, R_\red, P_\blue \setminus \{\{v\}\}, R_\blue)], & \text{otherwise},
		\end{cases} \\
	\end{align*}
\end{lemma}
%
The state \( (P_\red \setminus \{\{v\}\}, R_\red, P_\blue \setminus \{\{v\}\}, R_\blue) \)
represents the state where \( v \) is not present in any part
and where the same parts stay neighbors.
Recall that \( R_\red, R_\blue \) are relations --- sets of pairs.
%
\begin{proof}
	By definition, there are no almost NAC-colorings
	in \( G_t \) if \( G_t \) has no edges.
	%
	If vertex \( v \) is in a part of \( P_\red \) or \( P_\blue \) with other vertices,
	the cache value must be zero as \( v \) is an isolated vertex in \( G_t \)
	and therefore no almost NAC-colorings consistent with such state exists.
	Therefore, there must be a part \( \{v\} \).
	%
	Also, as \( v \) is an isolated vertex in \( G_t \), there cannot be a bridge
	connecting this and another component.
	Thus, for all states where there exists
	a part neighboring \( \{v\} \), there are no consistent almost NAC-colorings
	and therefore the cache value must be also zero.
	%
	By adding a vertex to \( G_{t'} \), we cannot create new almost cycles
	or extend existing almost NAC-colorings as no new edge was added.
	Therefore, the number of almost NAC-coloring for a state \( s \) must be the same
	as for the state \( (P_\red \setminus \{\{v\}\}, R_\red, P_\blue \setminus \{\{v\}\}, R_\blue) \).
\end{proof}
%
To summarize, already computed values are propagated to the states
where \( v \) stays isolated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Forget Vertex Node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lemma}%
	\label[lemma]{lemma:fpt_forget_vertex_node}
	%
	Let a \ForgetVertexNode{} \( t \in T \) be
	the only parent of \( t' \in T \) and let \( s \in S_t \).
	Let \( v \) be the only vertex in \( X_{t'} \setminus X_t \).
	%
	If there are no edges in the graph \( G_t \), then \( c[t, s] \coloneqq 0 \).
	%
	Otherwise, we define the cache function value for \( s=(P_\red, R_\red, P_\blue, R_\blue) \)
	for \( a \in \{\red, \blue\} \) as:
	%
	\begin{align*}
		c[t, s]            & \coloneqq \sum_{s' \in S'} c[t', s'],                                                                           \\
		\text{where}                                                                                                                         \\
		m(p)               & \coloneqq p \setminus \{v\},                                                                                    \\
		M(P)               & \coloneqq \{m(p) \mid p \in P \} \setminus \{\emptyset\},                                                       \\
		\mathcal{P'}_a     & \coloneqq \{ P_a' \in \mathcal{F}(X_{t'}) \mid M(P_a') = P_a \},                                                \\
		\mathcal{R'}(P_a') & \coloneqq \{ R_a' \subseteq P_a' \times P_a' \mid \forall (p_1, p_2) \in R_a' :                                 \\
		                   & \qquad (m(p_1), m(p_2)) \in R_a \lor m(p_1) = \emptyset \lor m(p_2) = \emptyset \},                             \\
		S'                 & \coloneqq \{(P_\red', R_\red', P_\blue', R_\blue') \mid P_a' \in \mathcal{P'}_a, R' \in \mathcal{R'}(P_a')  \}. \\
	\end{align*}
\end{lemma}
%
\( m(p) \) denotes deletion of  the vertex \( v \) from a part \( p \).
\( M(P) \) denotes deleting the vertex \( v \) from all the parts in partition \( P \)
--- if \( \{v\} \in P \), \( \emptyset \) is also cleared.
\( \mathcal{P'}_a \) denotes all the partitions such that removing \( v \) from them gives \( P_a \).
\( \mathcal{R'}(P_a') \) denotes all the relations \( R_a' \)
for \( P_a' \in \mathcal{P'}_a \) that correspond with \( R_a \) when \( v \) are removed
--- parts are updated or relations to \( \{v\} \) is removed.
\( S' \subseteq S_{t'} \) is the set of all states that
correspond to state \( s \) when \( v \) is removed.
%
\begin{proof}
	If there are no edges in \( G_t \), none are added by a \ForgetVertexNode{}.
	Therefore, \( c[t, s] \coloneqq 0 \).
	%
	Otherwise, we know that \( G_t = G_{t'} \) and therefore
	almost NAC-colorings over the
	state spaces \( S \) and \( S_{t'} \) are the same.
	%
	As \( v \) was removed from \( X_{t'} \),
	corresponding states in \( S' \) can to be adapted and mapped to \( S_t \).
	%
	For each state \( s \in S_t \) we find a set of states in \( S' \)
	that correspond to the same almost NAC-colorings.
	First such states are where \( v \) was in its own part \( \{v\} \)
	and remaining parts and corresponding relations are the same as in \( s \).
	The other is where \( v \) was in a part where after removal of \( v \) and
	after updating the neighboring relation we get the same parts as in \( s \).
	These properties must hold for both colors.
	%
	As \( S_t \) and \( S_{t'} \) differ only in \( v \),
	we covered the whole state space and gave each state in \( S_t \) disjoint
	set of states in \( S' \).
	%

	% If \( v \) did not share a component with other vertices,
	% and if we later add an edge \( e = \{u, v\}, u, v \in X_t \) to the graph,
	% no almost cycle using \( v \) cannot be created as entering and leaving the component
	% requires more than one edge of each color.
	% %
	% Lastly if \( v \) shares a component with other vertices,
	% and an almost cycle passing through \( v \) is created in the future,
	% in can be rerouted to pass through other vertices of the component,
	% If not there is a bridge incident to \( v \), such information if passed
	% further using neighboring relation and such cycle will be found.
	% Therefore, the number of NAC-colorings stays the same if we remove \( v \)
	% from  partitions.
	% %
	% The resulting cache entry holds values from both the state types.
\end{proof}
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduce Edge Node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
When discussing \IntroduceEdgeNode{} intorducing edge \( e \),
we first describe states in \( S_{t} \)
that cannot correspond to any almost NAC-coloring in \( G_t \).
If they can, we call them \emph{allowed}, otherwise they are \emph{not allowed}.
To avoid confusion, note that in the following statements we assume
a state \( s \in S_t \) after the edge \( e \) is added, not a state \( s' in S_{t'} \).
%
An edge \emph{lies} in a part if both its endpoints are in the part.
An edge \emph{connects} two parts if its endpoints are each in these parts.
%
We state conditions for an edge colored by one color first,
w.l.o.g.\ let the introduced edge \( e \) be colored \( \blue \).
We first state conditions for \( \blue \) half of a state \( s \):
%
\begin{description}
	\item[Edge \( e \) lies in a \( \blue \) part]
	      In this trivial case, an almost cycle is not created in \( \blue \) components.
	      This is \emph{allowed}.
	      %
	\item[Edge \( e \) connects two neighboring \( \blue \) parts]
	      This causes an almost cycle to be created as
	      components corresponding to the parts
	      are now a single component.
	      Therefore, the state \( s \) does not describe
	      the actual state for any almost NAC-coloring in \( G_t \)
	      as there should be only a single part, and therefore this is \emph{not allowed}.
	      %
	\item[Edge \( e \) connects two non-neighboring \( \blue \) parts]
	      This state is \emph{not allowed} as both parts
	      are now using this \( \blue \) edge and should be one part.
	      This is \emph{not allowed}.
\end{description}
%
Now we state conditions for \( \red \) half of a state \( s \):
%
\begin{description}
	\item[Edge \( e \) lies in a \( \red \) part]
	      In this case, an almost cycle is trivially created
	      through the \( \red \) component,
	      therefore this is \emph{not allowed}.
	      %
	\item[Edge \( e \) connects two neighboring \( \red \) parts]
	      This is \emph{allowed} as \( e \) is a bridge and
	      therefore the parts need to be neighboring.
	      %
	\item[Edge \( e \) connects two non-neighboring \( \red \) parts]
	      This state is \emph{not allowed} as both parts
	      are now neighboring as \( e \) is a bridge.
	      This is \emph{not allowed}.
\end{description}
%
\begin{observation}%
	\label[observation]{observ:introduce_edge_allowed}
	%
	A state is \emph{allowed} only if its both halves are allowed.
	Otherwise, no almost NAC-coloring in \( G_t \)
	where \( e \) is colored \( \blue \) can correspond to the state.
\end{observation}
%

\begin{lemma}%
	\label[lemma]{lemma:fpt_introduce_edge_node}
	%
	Let us have an \IntroduceEdgeNode{} \( t \in T \) that is
	the only parent of \( t' \in T \) and state \( s \in S_t \).
	It holds that \( X_t = X_{t'} \),
	let \( e \) be the only edge added in the step, \( e \in Y_t \setminus Y_{t'} \).
	%
	If there is only a single edge \( e \) in \( G_t \) (the just introduced edge),
	the cache value is set as \( c[t, s] \coloneqq 2 \).
	%
	Otherwise, if the state \( s \) is not allowed, then \( c[t, s] \coloneqq 0 \).
	%
	For an allowed state \( s \),
	the only states \( s' = (P_\red', R_\red', P_\blue', R_\blue'), s' \in S_{t'} \),
	whose corresponding almost NAC-colorings are extended
	to almost NAC-colorings corresponding to \( s \) by adding \( \blue \) edge \( e \),
	are the states that fulfill these conditions for their both halves:
	%
	\begin{description}
		\item[Edge lies in a \( \blue \) part]
		      There are two conditions for the \( \blue \) half of a state \( s' \).
		      %
		      The first is condition that \( P_\blue = P_\blue' \)
		      and \( R_\blue = R_\blue' \) must hold.
		      %
		      The other condition is that the endpoints of \( e \)
		      must be in different \( \blue \) parts \( p_1, p_2 \in P_\blue' \)
		      such that these parts are not neighboring, e.g.\ \( (p_1, p_2) \not\in R_\blue' \).
		      The other parts are the same as in \( P_\blue \),
		      except for part \( p = p_1 \cup p_2, p \in P_\blue \),
		      e.g.\ \( P_\blue' \setminus \{p_1, p_2\} = P_\blue \setminus \{p\} \).
		      \( R_\blue \) and \( R_\blue' \) must also match accordingly.
		      %
		      Either of the conditions has to be fulfilled.

		      % First we query the previous cache state with
		      % the same partition and neighbors state.
		      % Then we also need to add states where
		      % both the components were not neighbors as no almost cycle was created
		      % and both the separate components
		      % are now joined into a single component.
		      % We denote \( \blue \) components of such state
		      % as \( P_\blue' \) and \( R_\blue' \).
		      % Note, that other relations between partitions need to match.
		      %
		\item[Edge connects two neighboring \( \red \) parts]
		      There are two conditions for the \( \red \) half of a state \( s' \).
		      %
		      The first condition is that \( P_\red = P_\red' \)
		      and \( R_\red = R_\red' \) must hold.
		      %
		      Now, let \( p_1, p_2 \in P_\red \) be the \( \red \) parts
		      of vertices incident to \( e \).
		      The other condition is that \( P_\red = P_\red' \) and
		      \( R_\red \setminus \{(p_{1}, p_{2}), (p_{2}, p_{1})\} = R_\red' \) must hold.
		      %
		      Either of the conditions has to be fulfilled.

		      % Result is a sum of previous states with the same partitioning as \( P_\red \),
		      % for first query we use \( R_\red \),
		      % and then we add query of \( R'_\red = R_\red \setminus \{(c(u), c(v)), (c(v), c(u))\} \)
		      % (with the neighbor constraint removed).
	\end{description}
	%
	There are four states \( s_1', s_2', s_3', s_4' \in S_{t'} \)
	that fulfil these conditions, one for each condition combination.
	%
	The value for \( \blue \) color is computed as follows:
	%
	\begin{align*}
		c_\blue[t, s] & \coloneqq c[t', s_1'] + c[t', s_2'] + c[t', s_3'] + c[t', s_4']. \\
		% c_\blue[t, s] & = c[t', (P_\red, R_\red, P_\blue, R_\blue)]                      \\
		%               & + c[t', (P_\red, R_\red', P_\blue, R_\blue)]               \\
		%               & + c[t', (P_\red, R_\red, P_\blue', R_\blue')]        \\
		%               & + c[t', (P_\red, R_\red', P_\blue', R_\blue')]
	\end{align*}
	%
	We compute the value for \( \red \) analogically.
	The final cache value is \( c[t, s] \coloneqq c_\red[t, s] + c_\blue[t, s] \).
\end{lemma}
%
\begin{proof}
	The case when \( e \) is the only edge is trivial.
	%
	As shown in \Cref{observ:introduce_edge_allowed},
	only allowed states may correspond to almost NAC-colorings on \( G_t \).
	%
	By adding a single \( \blue \) edge \( e \),
	an almost NAC-coloring of \( G_{t'} \)
	is extended to an almost NAC-coloring of \( G_t \)
	or an almost cycle is created.
	%
	Let us consider the \( \red \) edge \( f \) with different color in the almost cycle.
	Then there is a \( \blue \) path connecting its endpoints using \( e \).
	Therefore, there must be two \( \blue \) components \( p_1', p_2' \)
	connecting endpoints of \( e \) to \( f \).
	\( f \) must be a bridge connecting \( p_1' \) and \( p_2' \),
	therefore parts \( p_1' \) and \( p_2' \) are neighboring.
	But we do not consider such states in \( s_1', \dots, s_4' \).
	%
	Let us now consider the edge with different color in the almost cycle is \( \blue \).
	Then the edge must be \( e \) and there must be a \( \red \) path connecting its endpoints.
	This path must be in a single \( \red \) component corresponding
	to a \( \red \) part \( p \in P_\red' \land p \in P_\red \).
	But we do not consider such states in \( s_1', \dots, s_4' \).
	%
	Only almost NAC-colorings
	corresponding to states \( s_1', \dots, s_4' \)
	are extended to almost NAC-colorings corresponding to \( s \)
	while producing no almost cycles.
	%
	Each state \( s' \in S_{t'} \) is extended by one color
	to exactly one state \( s \in S_t \) and for each allowed state \( s \)
	the states \( s_1', \dots, s_4' \) trivially exists.
	%
	It is easy to see that by adding \( \blue \) colored edge \( e \) to \( G_{t'} \),
	we extend states \( s_1', \dots, s_4' \) to allowed states in \( S_{t} \)
	and that no other state preserve correspond to the same extended almost NAC-colorings.
	%
	As we covered all allowed states in \( S_t \),
	we also over all almost NAC-colorings in \( G_t \) where \( e \) is colored \( \blue \).
	%
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Join node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In the following paragraphs,
we prepare terms that will come useful in \Cref{lemma:fpt_join_node}.
Let us have a \JoinNode{} \( t \in T \) that is
the only parent of \( t_1', t_2' \in T \).
It holds that \( X_t = X_{t_1}' = X_{t_2}' \),
\( G_{t_1'} \ne G_{t_2'} \)
and \( S_t = S_{t_1'} = S_{t_2'} \)
(we abbreviate them to \( S, S_1', S_2' \)).
%
In the previous lemmas we created cache entries for a state \( s \in S \).
Now, we find a state \( s \in S \) corresponding to states \( s_i' \in S_i', s_2' \in S_2' \).
Our goal is to somewhat merge overlapping parts in states \( s_1' \) and \( s_2' \)
into a state in \( s \) and check if \( s \) can correspond to any almost NAC-colorings.
%
We create mappings \( M: S_1' \times S_2' \to S \) and \( N: S_1' \times S_2' \to \{0, 1\} \).
Mapping \( M \) maps to the state where parts (components in \( G_t \)) of both the states
are merged together and \( N \) states if the produced state
can correspond to almost NAC-colorings on \( G_t \).

Let \( {(.)}^* \) denote the reflexive-transitive closure of a set.
For \( i \in \{1, 2\} \), let us have states
\( s_i' = (P_{i,\red}', R_{i,\red}', P_{i,\blue}', R_{i,\blue}'), s_i' \in S_i' \).
%
We process \( \red \) and \( \blue \) halves of the states separately.
For \( a \in \{\red, \blue\} \),
we take equivalence relations \( O_{i, a}' \)
whole equivalence classes are the partitions \( P_{i, a}' \),
\( P_{i, a}' = \equivclass{X_t}{O_{i, a}'}\).
We set
%
\begin{align*}
	O_a & \coloneqq {(O_{1, a}' \cup O_{2, a}')}^*, \\
	P_a & \coloneqq \equivclass{X_t}{O_a}.
\end{align*}
%
This operation represents merging colored components from both the states
--- if multiple components (transitively) intersect, they become one
component and therefore one part.
We do no almost NAC-coloring related reasoning or presumptions yet.

We continue with neighbors relation. We remove connections of parts
that were merged and updated the relations to correspond with the new parts.
For \( i \in \{1, 2\} \) let
%
\begin{align*}
	R_{i,a} & \coloneqq \{(p_1, p_2) \in P_a \times P_a \mid p_{1} \ne p_{2} \land                                                    \\
	        & \qquad \exists p_1', p_2' \in P_{i,a}' : (p_1', p_2') \in R_{i,a}' \land p_1' \subseteq p_1 \land p_2' \subseteq p_2\},
\end{align*}
%
and let \( R_a \coloneqq R_{1,a} \cup R_{2,a} \).
Then we define mapping \( M \) as
\[ M(s_1', s_2') \coloneqq (P_\red, R_\red, P_\blue, R_\blue). \]

We follow with mapping \( N \) that tells whether the merge done by \( M \)
of states \( s_1' \) and \( s_2' \), \( s = M(s_1', s_2') \),
can possibly correspond to any almost NAC-coloring on \( G_t \).
%
Let \( a \in \{\red, \blue \} \) and \( b \in \{\red, \blue \} \setminus \{a\} \).
If there exists \( p \in P_{a} \)
and \( \mathcal{P}_{i, a}' \subseteq P_{i, a}' \) such that \( \bigcup_{p' \in \mathcal{P}_{i, a}'} p' = p \)
and there exists \( p_1', p_2' \in \mathcal{P}_{i, a}' : (p_1', p_2') \in R_{i, a}' \),
the state \( s \) is \emph{bad} as an almost cycle is created
using a \( \red \) bridge connecting \( p_1' \) and \( p_2' \) and \( \blue \) path
in the component in \( G_t \) corresponding to \( p \).
%
We denote set of such bad state pairs (for both colors) as \( \mathcal{B} \subseteq S_1' \times S_2' \).
%
\begin{align*}
	N(s_1', s_2') =
	\begin{cases}
		0, & \text{if } (s_1', s_2') \in \mathcal{B}, \\
		1, & \text{otherwise}.
	\end{cases}
\end{align*}
%

\begin{lemma}%
	\label[lemma]{lemma:fpt_join_node}
	%
	Let us have a \JoinNode{} \( t \in T \) that is
	the only parent of \( t_1', t_2' \in T \) and mappings \( M, N \) as defined above.
	%
	If \( G_{t_1'} \) and \( G_{t_2'} \) have no edges, then and \( c[t, s] = 0 \) for each \( s \in S \).
	If only one of \( G_{t_1'} \) and \( G_{t_2'} \) has no edges,
	w.l.o.g.\ let \( G_{t_1'} \) have no edges,
	then \( c[t, s] = c[t_2', s] \) for each \( s \in S \).
	%
	Otherwise, both \( G_{t_1'} \) and \(G_{t_2'} \) have some edges.
	%
	The following formula computes cache value based on previously defined mappings.
	It comes from the same idea as NAC-product (\Cref{def:NACproduct}) where all the resulting colorings
	are NAC-colorings. The size of such product is multiple of the numbers of
	almost NAC-colorings on \( G_{t_1'}, G_{t_2'} \).
	%
	\begin{align*}
		\mathcal{S}(s) & \coloneqq \{(s_1', s_2') \in S_{t_1'} \times S_{t_2'} \mid M(s_1', s_2') = s \}                            \\
		c[t, s]        & \coloneqq \sum_{(s_1', s_2') \in \mathcal{S}(s)} N(s_1', s_2') \cdot c[t_1', s_1'] \cdot c[t_{2}', s_{2}']
	\end{align*}
	%
\end{lemma}
%
\begin{proof}
	First we show that partitions produced by mapping \( M \)
	correspond to components in \( G_t \).
	Let us have almost NAC-colorings \( \delta_i' \) corresponding
	to \( s_i' \) in \( G_{t_i'} \).
	For simplicity, we assume that \( Y_t = \emptyset \)
	as shown in \Cref{lemma:join_node_no_edges}.
	Let us join the two almost NAC-colorings \( \delta_1' \) and \( \delta_2' \)
	to obtain an almost NAC-coloring \( \delta \) on \( G_t \).
	%
	Let us find components in \( G_t \).
	The components have to be the same or larger
	than the components in \( G_{t_1'} \) and \( G_{t_2'} \).
	%
	If two \( \blue \) components \( C_1', C_2' \),
	one from \( G_{t_1'} \) with \( \delta_1' \) and
	the other from \( G_{t_2'} \) with \( \delta_2' \),
	are merged into one \( \blue \) component \( C \) in \( G_t \),
	there must be a \( \blue \) path connecting them.
	The path must visit vertices \( p_1, \dots, p_l \in X_t \)
	and switch from \( \blue \) components in \( G_{t_1'} \)
	to \( \blue \) components in \( G_{t_2'} \) or the other way around.
	%
	The reflexive-transitive closure in definition of \( M \) ensures that
	all parts corresponding to visited \( \blue \) components
	get merged into common part \( p \in P_a \).
	This part naturally corresponds to the component \( C \) in \( G_t \).
	%
	If two components \( C_1, C_2 \) corresponding to
	parts \( p_1', p_2' \in P_{i,a}' \) in \( G_{t_i'} \) are neighboring,
	all the parts merged with them preserve the property
	(unless \( p_1' \) gets merged with \( p_2' \)).
	No other new neighboring relations can be introduced
	as there are no new edges introduced by \( t \) and \( Y_t = \emptyset \).

	Now we show, that \( N \) gives \( 1 \) only if the state \( s \),
	corresponds to almost NAC-colorings on \( G_t \)
	that are merged from almost NAC-colorings on \( G_{t_1'} \) and \( G_{t_2'} \)
	for states \( s_1', s_2' \).
	%
	A state \( s \in S \) is suitable unless configurations
	introduce an almost cycle in \( G_t \).
	%
	% We need to validate that we did not create an almost cycle.
	% An almost cycle is created if there exist \( p_1', p_2' \in P_{i,a}' \)
	% such that there exists \( p \in P_a : p_1' \cup p_2' \subseteq p \)
	% and \( (p_1', p_2') in R_{i,a}' \)
	% --- there was a bridge connecting \( p_1' \) and \( p_2' \),
	% but now the bridge is inside a component corresponding to \( p \),
	% and it creates an almost cycle.
	%
	% The rest of the statement follows similar in introduce edge node proof.
	% The check is done once again for both the colors.
	%
	Let us go through cases how can an almost cycle be created.
	%
	Suppose the only edge with different color in an almost cycle is colored \( \red \).
	Then there must exist a \( \blue \) path connecting its endpoints.
	%
	If the path spans only vertices
	in \( V_{t_1'} \), there is no almost NAC-coloring considered in \( c[t_1', s_1'] \)
	as it is not an almost NAC-coloring on \( G_{t_1} \).
	%
	Therefore, the \( \red \) edge must be
	a bridge connecting two \( \blue \) components in \( P_{1,\blue} \),
	and the path has to also visit multiple vertices in \( V_{t_2'} \).
	As shown in the proof of the mapping \( M \), \( \blue \) components
	visited by such path are merged together.
	%
	If also done for almost cycles with a \( \blue \) edge,
	these are exactly the bad states as described in the definition of \( N \).

	Lastly, we show that the value stored in the cache corresponds
	to the number of almost NAC-colorings on \( G_t \) consistent with \( s \).
	We consider only states where \( N(s_1', s_2') = 1 \)
	as the value of other states does not matter.
	%
	For \( \delta_i' \) as defined above, \( \delta \) is an almost NAC-coloring
	on \( G_t \) as we showed that there are no almost cycles formed.
	%
	Assume we have an almost NAC-coloring \( \gamma \) on \( G_t \) consistent with \( s \)
	that is not accounted for by merging some \( \delta_i' \).
	But a restriction of \( \gamma \) onto \( G_i \) produces an almost NAC-coloring
	consistent with \( s_i' \). This is a contradiction.
\end{proof}
%

%
\begin{lemma}%
	\label[lemma]{lemma:fpt_root_node}
	Let us have a \RootNode{} \( r \in T \) with unique child \( t' \).
	Then \( c[r, (\emptyset,\emptyset,\emptyset,\emptyset)] = c[t', (\emptyset,\emptyset,\emptyset,\emptyset)] \).
\end{lemma}
%
\begin{proof}
	The previous cache entry holds the number of almost NAC-colorings on \( G_{t'} \).
	As \( G_{t'} = G_r \), the number of almost NAC-colorings on \( G_r \) must be the same.
\end{proof}
%

%
\begin{theorem}%
	\label[theorem]{thm:fpt_algo}
	%
	There exists an FPT algorithm
	that for a given nice three decomposition \( T \) of \( G \)
	can find the number of NAC-colorings of \( G \) in time
	\( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot O(n) \) where \( n \) is the number of vertices of \( G \)
	and \( k \) is the width of \( T \).
\end{theorem}
%
\begin{proof}
	We compute values of the cache function on \( T \) in a bottom-up manner.
	We read the output of the \RootNode{} \( r \) as follows:
	%
	\begin{align*}
		\text{output} \coloneqq \max\{c[r, (\emptyset,\emptyset,\emptyset,\emptyset)] - 2, 0\}.
	\end{align*}
	%
	This gives us the number of NAC-colorings of \( G \) as \( G = G_r \).
	If the graph has no edges, we read \( 0 \), that is why we use \( \max{} \) in the reading.
	\( c \) always stores the number of almost NAC-colorings as proved by
	\Cref{%
		lemma:fpt_leaf_node,%
		lemma:fpt_introduce_vertex_node,%
		lemma:fpt_forget_vertex_node,%
		lemma:fpt_introduce_edge_node,%
		lemma:fpt_join_node,%
		lemma:fpt_root_node%
	}.
	There are only two almost NAC-colorings
	that are not NAC-colorings (the monochromatic ones), they get subtracted.
	From that it can be clearly observed that the algorithm
	will never give you up~\cite{never_gonna_give_you_up}.

	Bell numbers are defined as the number of partitions of a set.
	They can be upper bounded by \( n^n \), which is what we will use from now on.
	Recall that \( \forall t \in T : |X_t| \le k+1 \).

	First, size of the state space used is upper bounded.
	For each color there is up to \( {(k+1)}^{(k+1)} \) partitions of a bag and
	up to \( 2^{\binom{k}{2}} \) neighboring relations.
	Total state space size for each bag is therefore bounded by
	\( {\big({(k+1)}^{(k+1)} \cdot 2^{\binom{k}{2}} \big)}^2 = {(k+1)}^{2(k+1)} \cdot 2^{2 \binom{k}{2}} \).

	We go through all the nodes and state complexity of the operations performed in the node:
	%
	\begin{description}
		\item[\IntroduceVertexNode{}]
		      We need to fill a state space and copy previous values into the cache
		      which can be done in constant time per operation,
		      so the time complexity corresponds to the state space size:
		      \( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot O(1) \).
		\item[\ForgetVertexNode{}]
		      Even if the operation seams complex, we just need to traverse the state space
		      and create target state after \( v \) is removed. This can be done in \( O(k) \) time
		      per state, total complexity therefore is
		      \( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot O(k) \).
		\item[\IntroduceEdgeNode{}]
		      The state space is iterated again, and we run few simple checks and cache key constructions
		      that can be run in \( O(k) \) time, therefore the final complexity stays the same
		      \( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot O(k) \).
		\item[\JoinNode{}]
		      We iterate through product of state spaces,
		      so the size of the new spate space is power of two
		      of the otherwise used state space size.
		      This hides into the big \( O \) notation.
		      Checks run checking for almost cycles can be run in time \( O(k^2) \).
		      Thus, the final		complexity is
		      \( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot O(k^2) \).
	\end{description}
	%
	There are \( O((n+m)k) \) nodes in \( T \) where \( m \) is bounded by \( O(kn) \).
	The final complexity of the algorithm is therefore
	\( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot O(n) \).
\end{proof}
%

\subsection{\IntroduceVertexWithEdgesNode{}}

As we also mentioned before, FPT algorithms parametrized by treewidth
often use \IntroduceVertexNode{} in such a way
that edges incident to the introduced edge and to
the vertices in the bag are also considered.
For this section, we call such behaving node an \IntroduceVertexWithEdgesNode{}.
Our original algorithm can be modified to use this node instead.
We outline the proof of correctness of such operation and show
that it is actually asymptotically slower than the originally proposed algorithm.

We consider a nice tree decomposition \( T \) as defined originally
with no \IntroduceEdgeNode{}s.
There are no behaving changes for
\LeafNode{}, \RootNode{}, \ForgetVertexNode{} nor \JoinNode{}
todo[inline]{Uncomment footnote}{
% \footnote{
In the proof of lemma \Cref{lemma:fpt_join_node}
regarding \JoinNode{} we required that \( Y_t = \emptyset \).
This is not a requirement as if an edge in \( Y_t \) is assigned two colors
by \( \delta_1', \delta_2' \), the endpoints are in common parts for both colors
and a contradiction is still detected.
}.

Let us describe how \IntroduceVertexWithEdgesNode{} processes cache entries.
Before, when a single edge was added,
we checked if there is some constraint violation
--- if an almost cycle was formed.
The same is also done for \IntroduceVertexWithEdgesNode{},
but you can think of the process as
multiple such constrains checks at the same time.

As it is nontrivial and confusing to describe this operation
by using predicate logic, we stick to natural language for simplicity.
Suppose that \( t \in T \) is
the only parent of \( t' \in T \).
Let \( v \) be the only vertex in \( X_t \setminus X_{t'} \).
Let \( F \) be the introduced edges,
\( F = \{ \{ u, v \} \mid u \in X_t \} \cap E(G) \).
%
Let us have a set \( \Lambda \) of all almost NAC-colorings on \( F \)
(trivially found for a star).
We define mapping \( m: S' \times \Lambda \to S \)
that represents how state changes for a coloring of edges in \( F \).
Let us have some \( s' \in S' \) and \( \lambda \in \Lambda \)
and \( m(s', \lambda) = s \in S \).

Vertices \( u, v \in X_t \) share the same \( \blue \) component if either:
%
\begin{itemize}
	\item They shared the same component in \( s' \).
	\item There is a \( \blue \) path in \( F \) with coloring \( \lambda \).
\end{itemize}
%
Note that \( \blue \) components created by following this procedure
are same as in \( s' \) or merged \( \blue \) components of \( s' \)
except for \( v \) as it is not yet in \( X_{t'} \).
Such \( \blue \) components are neighboring if either:
%
\begin{itemize}
	\item They or their predecessors in \( s' \)
	      were neighbors in \( s' \).
	\item There is a path in \( F \) with
	      one \( \blue \) and one \( \red \) edge
	      according to coloring \( \lambda \).
	      The \( \red \) edge becomes a bridge.
\end{itemize}
%
Now the same is done for \( \red \).
We ensure that all the rules described in \IntroduceEdgeNode{}
still hold for \( s \). If so, \( c[t, s] \pluseq c[t', s'] \).
This all is done for each combination in \( S' \time \Lambda \).

For the original algorithm for each \( v \)
\IntroduceEdgeNode{} is used \( |F| \) times
and \( \IntroduceVertexNode{} \) once, therefore added complexity for \( v \)
is \( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot (|F| + 1) \).
%
For \IntroduceVertexWithEdgesNode{} we iterate
through all the colorings in \( \Lambda \) for each state.
The size of \( \Lambda \) is \( |\Lambda| = 2^{|F|} = 2^{O(k)} \),
the required runtime added for \( v \) is
\( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot 2^{O(k)} = {k}^{O(k)} \cdot 2^{O(k^3)}\)
which is asymptotically higher.



\subsection{Monochromatic components}

Monochromatic components can be used to significantly reduce the state space
that needs to be searched as for some cache entries we can say that
they resolve to zero without solving related sub-problems.
%
First we introduce state space reduction when
there is an edge in a bag, then we extend the result to multiple edges
sharing the same monochromatic component, and lastly we improve the number of
operations needed in the \IntroduceVertexWithEdgesNode{}.
%
\begin{lemma}
	Let us have \( t \in T \) and an edge \( e = \{u, v\} \) in \( Y_t \).
	For a state \( s = (P_\red, R_\red, P_\blue, R_\blue), s \in S_t \)
	such that it holds that
	\( {\forall a \in \{\red, \blue\}} : {\forall p_a \in P_a} : {u \in p_a \Rightarrow v \not\in p_a} \),
	it then also holds that \( c[t, s] = 0 \).
\end{lemma}
%
%
\begin{proof}
	For contradiction, suppose that such state corresponds
	to some almost NAC-coloring \( \delta \).
	The edge \( e \) has to be either \( \red \) or \( \blue \).
	Let w.l.o.g.\ \( e \) be colored \( \blue \).
	That means that both \( u, v \) are in the same \( \blue \) component.
	But the state \( s \) states that \( u, v \) do not share a \( \blue \) component.
	Then \( \delta \) does not correspond to the state \( s \).
	This is a contradiction.
\end{proof}
%

We extend the result for monochromatic components as follows:
see that this is just a generalization of the previous theorem
as an edge forms a trivial monochromatic class.
%
\begin{theorem}
	For \( t \in T \),
	edges \( F \subseteq Y_t \) such that
	they share the same monochromatic component
	and vertices \( U \) such that they are end points of the edges in \( F \).
	Then for states \( s = (P_\red, R_\red, P_\blue, R_\blue), s \in S \)
	such that it holds that
	\( \forall a \in {\red, \blue}: \forall p_a \in P_a : U \not\subseteq p_a \),
	it then also holds that \( c[t, s] = 0 \).
\end{theorem}
%
%
\begin{proof}
	For contradiction suppose that such state corresponds to an almost NAC-coloring \( \delta \).
	The edges \( F \) has to be either \( \red \) or \( \blue \).
	Let w.l.o.g.\ edges in \( F \) be colored \( \blue \).
	That means that all vertices in \( U \) are in the same \( \blue \) component (and part)
	as the edges are from a monochromatic component.
	But the state \( s \) states that there is a vertex \( u \in U \)
	that does not share a \( \blue \) component with the other vertices in \( U \).
	Then \( \delta \) does not correspond to the state \( s \).
	This is a contradiction.
\end{proof}
%

Lastly, we show how \IntroduceVertexWithEdgesNode{} can be optimized.
First, while traversing all the colorings of the edges \( F \) incident to the added vertex,
we do not try all the color combinations as usual. If there are some edges
in \( Y_{t'} \cup F \) that are part of a monochromatic component,
the same as above applies. We cannot create a contradicting state with non-zero
cache entry. But by using monochromatic classes
we can enforce that all such edges should always have the same color.
We can also enforce the color by using an edge of the same monochromatic class
that is a part of \( Y_{t'} \).
For example, if the edge in \( Y_{t'} \) lies in a \( \blue \) part,
the other edges from the same monochromatic component
can be added and checked as \( \blue \).


\subsection{Connectivity}

Along with the cache we can also hold an information about connectivity of
vertices in bags.
%
\begin{definition}[Connectivity map]
	Let \( t \in T \) be a node in a nice tree decomposition tree and
	\Xt{} be a bag of vertices.
	A \emph{connectivity map} \( C_t \) is a partition of \Xt{}.
	For each \( u, v \in X_t \), it holds that
	\( \exists c \in C_t : u \in c \land v \in c \) iff
	\( u, v \) are in the same component in \( G_t \).
\end{definition}
%
\begin{lemma}
	A state \( s \in S_t \) is \emph{in conflict} with \( C_t \)
	if both \( P_\red \) and \( P_\blue \) are not same or finer that \( C_t \).
	For such states we have \( c[t, s] = 0 \).
\end{lemma}
%
\begin{proof}
	For contradiction, suppose that such state \( s \)
	corresponds to an almost NAC-coloring \( \delta \).
	It must hold that \( C_t \ne \{X_t\} \), otherwise \( s \) cannot be in conflict.
	For each \( c_1, c_2 \in C_t, c_1 \ne c_2, u \in c_1, v \in c_2 \)
	there is no \( u \)--\( v \)--path in \( G_t \).
	But state \( s \) states that there is such a path for some \( u, v \) as it is not finer.
	Therefore, \( s \) does not correctly describe situation in \( G_t \)
	and cannot therefore correspond \( \delta \).
\end{proof}
%
We show how connectivity map changes for different types of nodes.
Consider a node \( t \in T \) and its child \( t' \)
or children \( t_1, t_2 \) in case of a \JoinNode{}.
%
For an \IntroduceVertexNode{}
a new connectivity map is obtained as follows:
\( C_t \coloneqq C_t' \cup \{\{ v \}\} \).
%
For a \ForgetVertexNode{}
a new connectivity map is obtained as
\( C_t \coloneqq M(C_t') \)
where \( M \) is mapping from \Cref{lemma:fpt_forget_vertex_node} 
deleting occurrences of forgotten vertex from the partition given.
%
For an \IntroduceEdgeNode{}
where edge \( \{u, v\} \) is introduced
parts of \( u, v \) are merged if they are not merged already.
%
For a \JoinNode{}
connectivity maps \( C_{t_1}, C_{t_2} \) are merged into
a single connectivity map \( C_t \)
the same way as when a \JoinNode{} is processed using mapping \( M \).
%
For a \LeafNode{}
no vertices are present yet, so for the connectivity map it holds that \( C_t = \emptyset \).

With such connectivity map, we can not reduce the state space by only considering
partitions that are finer then the connectivity map.


\subsection{NAC-coloring certificate}

To obtain a NAC-coloring certificate or all the NAC-colorings of the graph
given we need to traverse the cache backwards recursively.
The only step where edges were added to the graph are either \IntroduceEdgeNode{}
or \IntroduceVertexWithEdgesNode{}. In both cases the given cache entry correspond
to some color given to the edge. From the recursive step we can obtain
all NAC-colorings of \( G_{t'} \) and add our edge.
Note that the whole cache has to be stored in memory the whole time unless
NAC-colorings are materialized while the algorithm runs.
This would harm our performance as we would
process up to \( 2^{O(n^2)} \) colorings in each node of the tree.


\subsection{Other optimizations}

It is trivial to see that if the input graph has an articulation,
we can once again run our algorithm on each block of the graph separately
and then multiply the results together to get the final result
while also considering monochromatic colorings of each block.
Note that the same can be done for disconnected graphs.

There is possibility that the algorithm can be further improved by creating
a Monte Carlo algorithm or a linear algebra based algorithm that can run
in \( O(c^k), c \in \N \) time as~\cite{book_parametrized_algorithms} suggests
for problems with connectivity requirements.
Monte Carlo algorithms are randomized algorithms whole output may be incorrect
with some probability. As they are often faster, they are run many times
to obtain trustworthy results.
This is unfortunately far beyond the scope of this thesis.

