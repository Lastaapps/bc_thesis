
\chapter{NAC-coloring counting fixed-parameter tractability}%
\label{chapter:fpt}

\begin{chapterabstract}

	It can be easily shown that the NAC-coloring existence as an NP-complete
	problem can be parameterized by treewidth by using \( \text{MSO}_2 \) logic.
	In this chapter, we present an algorithm that can obtain
	the number of NAC-coloring of a graph in \({k}^{O(k)} 2^{O(k^2)} n^{O(1)}\) time,
	where \(k\) stands for the treewidth of the graph.

\end{chapterabstract}

\section{Treewidth}

We use notation as used in~\cite{book_parametrized_algorithms}.
Treewidth is one of many graph parametrizations like
pathwidth, cliquewidth, maximum degree and many others.
These approaches are used to somehow exploit graphs structure
and provide algorithms with possibly significantly lower time complexity
than algorithms considering general graphs only.
For a list of other common parametrization approaches,
we recommend~\cite{tree_width_comparision_other_classes}.
Using these approaches, many NP-complete problems can be solved
in a time polynomial in \( |V(G)| \)
for many graph classes that have such a bounded structural property.
To name a few such problems:
\textsc{Vertex Cover}, \textsc{Dominating Set}, \textsc{Longest Path}, \dots

First we provide a formal definition:
%
\begin{definition}[\cite{book_parametrized_algorithms}]
	A \emph{parameterized problem} is a language \( L \subseteq \Sigma^* \times \N \), where
	\( \Sigma \) is a fixed, finite alphabet. For an instance \( (x, k) \in \Sigma^* \times \N \), \( k \) is called the
	parameter.
	%
	We define the size of an instance \( (x, k) \) of a parameterized problem as \( |x| + k \).
\end{definition}
%
\begin{definition}[\cite{book_parametrized_algorithms}]
	A parameterized problem \( L \subseteq \Sigma^* \times \N \) is called \emph{fixed-parameter tractable} (FPT)
	if there exists an algorithm \( \mathcal{A} \) (called a fixed-parameter
	algorithm), a computable function \( f: \N \to \N \), and a constant
	\( c \) such that, given \( (x, k) \in \Sigma^* \times \N \), the algorithm \( \mathcal{A} \)
	correctly decides
	whether \( (x, k) \in L \) in time bounded by \( f(k) \cdot |(x, k)|^c \). The complexity
	class containing all fixed-parameter tractable problems is called FPT\@.
\end{definition}
%
Less formally we can say that FPT algorithms
have running time of \( f(k)\cdot n^c \)
where \( k \) is a parameter dependent on the instance,
\( n \) is the number of vertices,
and \( c \) is a constant.

In parameterized algorithms, \( k \) stands for different parameters
representing some form on internal graph structure as noted before.
%
For many problems, it is quite simple to find a fast solution on trees.
Often a dynamic programming approach is needed for that.
%
One of the most popular and simple approaches
is the use of treewidth and tree decomposition.
The metric tries to show how similar a graph is to a tree.
%
The usual goal of algorithms is to develop a dynamic programming algorithm
that exploits the tree-likeness of a graph.

%
\begin{definition}[Tree decomposition~\cite{book_parametrized_algorithms}]
	A \emph{tree decomposition} of a graph~\( G \) is
	a pair \( (T, {\{X_t\}}_{t \in V ( T )}) \)
	where \( T \) is decomposition tree and every node \( t \)
	is assigned a bag \( X_t \subseteq V(G) \) such that the following hold:
	%
	\begin{enumerate}
		\item \( \bigcup_{t \in V(T)} X_t = V(G) \),
		      i.e., each vertex is in at least one bag.
		\item For every \( \{u,v\} \in E(G) \), there exists
		      a node \( t \in T \) such that both \( u, v \in X_t \).
		\item For every \( u \in V(G) \),
		      the set \( \{t \in V(T) \mid u \in X_t\} \)
		      induces a connected subtree of \( T \).
	\end{enumerate}
\end{definition}
%
\begin{definition}[Treewidth~\cite{book_parametrized_algorithms}]
	The \emph{width} of a tree decomposition given by pair
	\( (T, {\{X_t\}}_{t \in V ( T )}) \)
	equals to \( \max_{t\in V(T)} |X_t| - 1 \).
	The \emph{treewidth} of a graph~\( G \) is the minimum such width
	across all tree decompositions of~\( G \).
\end{definition}
%
The width is decreased by one, so the treewidth of a tree is one.

Throughout the chapter we use term \emph{vertex} for vertices of \( G \)
and \emph{node} for nodes of \( T \).
We also shorten \( t \in V(T) \) to \( t \in T \).

We follow with a lemma that is important for all the related
dynamic programming approaches running on tree decompositions.
%
\begin{definition}[Vertex subset border~\cite{book_parametrized_algorithms}]
	Let \( A \subseteq V(G) \). Then the \emph{border} of \( A \) denoted by \( \beta(A) \)
	is the set of vertices
	\( \{u \in A \mid \exists v \in V(G) \setminus A : \{u, v\} \in E(G) \} \).
\end{definition}
%
\begin{lemma}[\cite{book_parametrized_algorithms}]
	Let \( (T, {\{X_t\}}_{t \in V ( T )}) \)
	be a tree decomposition of a graph~\( G \)
	and let \( \{a, b\} \in E(T) \).
	Then \( T - \{a, b\} \) consists of two connected components \( T_a, T_b \).
	%
	Let \( A = \bigcup_{t \in T_a} X_t \) and \( B = \bigcup_{t \in T_b} X_t \).
	Then \( \beta(A), \beta(B) \subseteq X_a \cap X_b \).
\end{lemma}
%
The lemma also reads as:
``\( X_a \cap X_b \) is a vertex cut in \( G \) and \( A, B \)
are distinct connected components''.

For a graph, many different tree decompositions can be obtained.
There may be for example multiple nodes with same bags or just a single node.
We also have no guarantee how two neighboring bags differ --- how many vertices changed.
Therefore, we want to define \emph{a nice tree decomposition} where neighboring nodes
represent some useful change between two bags.
First, we want our nice tree to be a rooted tree,
let \( r \in T \) be the root node.
%
\begin{definition}[Nice tree decomposition~\cite{book_parametrized_algorithms}]
	A tree decomposition \newline
	\( (T, {\{X_t\}}_{t \in V ( T )}) \) rooted at \( r \in T \)
	is \emph{nice} if the following conditions are satisfied:
	%
	\begin{itemize}
		\item \( X_r = \emptyset \) and \( X_l = \emptyset \) for every leaf node \( l \in T \).
		\item Every non-leaf node is one of the following types:
		      \begin{itemize}
			      \item \IntroduceVertexNode{} --- a node \( t \) with one child \( t' \)
			            such that \( X_t = X_{t'} \cup \{v\} \) where \( v \not\in X_{t'} \).
			            We say that \( v \) is \emph{introduced} by \( t \).
			      \item \ForgetVertexNode{} --- a node \( t \) with one child \( t' \)
			            such that \( X_t = X_{t'} \setminus \{v\} \) where \( v \in X_{t'} \).
			            We say that \( v \) is \emph{forgotten} by \( t \).
			      \item \JoinNode{} --- a node \( t \) with two children \( t_1, t_2 \)
			            such that \( X_t = X_1 = X_2 \).
		      \end{itemize}
	\end{itemize}
	%
	We denote the root node \( r \) by \RootNode{} and leaf nodes by \LeafNode{}.
	Vertex bags of these nodes are usually empty as in our case,
	but sometimes it is beneficial
	for the algorithm (like \textsc{SteinerTree}) that they contain a single vertex.
\end{definition}
%
\begin{figure}[ht]
	\begin{center}
		\includegraphics[width=0.80\textwidth]{./assets/nice_tree_decomposition.png}
	\end{center}
	\caption[Nice tree decomposition]{An example of a nice tree decomposition with width three~\cite{nice_tree_decomposition_img}.
		In (A) you can see the decomposed graph, in (B) a nice tree decomposition
		with \LeafNode{}s on the right and the \RootNode{} on the left.
	}%
	\label{fig:nice_tree_decomposition}
\end{figure}

\todo[inline]{Do in Tikz or SVG, maybe. If so, make leaf nodes empty}

Note that a vertex \( v \in V(G) \) can be introduced multiple times
(in multiple branches of \( T \)),
but forgotten only once.
%
Otherwise, there must be an \IntroduceVertexNode{} above a \ForgetVertexNode{} in~\( T \).
But then there are multiple subgraphs in \( T \)
such that \( v \) is in their every bag.
This does not fulfill the definition of a tree decomposition.

By \( V_t, t \in T \), we denote the set of vertices introduced by \( t \)
and all its child nodes.
%
\begin{lemma}[\cite{book_parametrized_algorithms}]
	Any tree decomposition of width at most \( k \) can be converted to
	a nice tree decomposition of width at most \( k \)
	in time \( O(k^2 \cdot \max(|V(T)|, |V(G)|)) \).
	The nice decomposition tree has at most \( O(k|V(G)|) \) nodes.
\end{lemma}

The problem of finding treewidth is NP-complete~\cite{tree_width_np_complete}.
Luckily, the problem is studied a lot and
there exist efficient approximation algorithms~\cite{tree_width_approximation}.
We consider nice tree decompositions as given along with a graph
and do not consider runtime required to find it.

In \IntroduceVertexNode{} introducing \( v \), all the edges incident to \( v \)
to vertices in \( X_{t'} \) are usually considered while processing \( t \).
%
For some problems, it is beneficial to divide this operation further.
First a vertex \( v \) is introduced with no edges using a \IntroduceVertexNode{}
and later all the edges corresponding to the vertex are introduced using new \IntroduceEdgeNode{}s
just before one of its vertices is forgotten.

We define an edge bag \( Y_t \subseteq E(G), t \in T \) similarly as vertex bags \( X_t \).
%
Let \( t' \) be a direct ancestor of~\( t \).
For \IntroduceVertexNode{}, we define \( Y_t = Y_{t'} \).
For \ForgetVertexNode{} forgetting vertex \( v \),
we define \( Y_t = Y_{t'} \setminus \{ e \in E(G) \mid v \in e\} \).
%
\begin{definition}[\IntroduceEdgeNode{}~\cite{book_parametrized_algorithms}]
	An \IntroduceEdgeNode{} node \( t \in T \) is a node
	labeled with an edge \( e = \{u, v\} \in E(G) \)
	such that \( u, v \in X_t \) and with exactly one child \( t' \)
	such that \( X_t = X_{t'} \), \( Y_t \setminus Y_{t'} = \{e\} \).
	We say that \( e \) is \emph{introduced} by \( t \).
	Each edge can be introduced at most once in \( T \).
\end{definition}
%
By \( E_t, t \in T \), we denote the set of edges introduced by \( t \)
and all its child nodes.
By \( G_t, t \in T \), we mean the graph \( G_t = (V_t, E_t) \).

For edge \( \{u, v\} \in E(G) \), we can transform a nice tree decomposition \( T \)
by adding \IntroduceEdgeNode{}s \( t \) above \IntroduceVertexNode{}s of \( u, v \)
and bellow \ForgetVertexNode{}s of \( u, v \in T \).
%
W.l.o.g., suppose that the \ForgetVertexNode{}~\( t_v \) of \( v \) is
an ancestor of the \ForgetVertexNode{}~\( t_u \) of \( u \in T \).
Let \( t_c \) be the only child of \( t_u \).
%
We add \IntroduceEdgeNode{}~\( t_e \) for edge \( \{u, v\} \)
as a direct child of \( t_u \) and make \( t_c \) the direct child of \( t_e \).
%
We can update a nice tree decomposition by doing
a top-down tree traversal and adding \IntroduceEdgeNode{}s for all edges.
The transformation requires \( O(nk) \) time (as the number of edges is bounded by \( nk \)).
From now on, we refer only to these transformed nice tree decompositions.

%
\begin{observation}
	\label[observation]{observ:no_edges_in_nodes}
	%
	The edge bag of each node except for \IntroduceEdgeNode{}s
	in a (transformed) nice tree decomposition \( t \in T \) is empty.
\end{observation}
%
This can be seen that the edges are added right before one of the vertices
they are incident to is forgotten. \ForgetVertexNode{} removes all the edges
that are incident to the forgotten vertex.

\todo[inline]{Image, maybe?}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Monadic second-order logic}

Monadic second-order logic~(\MSO{}) on graphs is a logical system based on
well known predicate logic.
In the world of parameterized algorithms,
it often comes handy --- if we are able to represent a problem using~\MSO{},
then there exists an FPT algorithm parameterized by treewidth
that can solve the problem~\cite{tree_width_mso}.

\subsection{Introduction to \( \text{MSO}_2 \)}

In the following paragraphs we paraphrase and simplify formal definition
from~\cite{book_parametrized_algorithms}.
We presume that reader is already familiar with first-order predicate logic.
Second-order predicate logic as an extension of first-order predicate logic,
that adds option to quantify over predicates.

\MSO{}~is realization of second-order predicate logic%
\nohznamka{
	We need second-order logic as quantification over subsets of vertices or edges
	corresponds to quantification over predicates defining the subsets.
	Without this requirement, we could talk
	about the monadic first-order logic \( \text{MSO}_1 \).
}.
Formulas can be formed from
variables, constants, predicates,
boolean operations \( \lnot, \land, \lor, \Rightarrow, \Leftrightarrow \)
and quantifiers \( \forall, \exists \).
Complex formulas are created recursively from atomic formulas
by applying schema related to each operation or quantifier.
This process is the same as in the first-order predicate logic.

Formulas of \MSO{} can use four types of variables:
single vertices, single edges, subsets of vertices, and subsets of edges.
%
An application of a graph \( G \) to a formula \( \phi \) is called \emph{evaluation}
of \( \phi \) in \( G \).
This represents the process of assigning values from \( G \) to variables in \( \phi \).
%
By \( u^G \) we denote evaluation of variable \( u \) in graph \( G \).
%
A \emph{free variable} is a variable such that it is not quantified by any predicate.
Let \( \Sigma \) denote all free variables of \( \phi \).
%
Let \( \Sigma^G \) be a sequence of evaluations for each variable in \( \Sigma \).
Tuple \( \langle G, \Sigma^G \rangle \) is called the \emph{structure}
in which \( \phi \) is evaluated.
If \( \phi \) is true in \( \langle G, \Sigma^G \rangle \),
then \( \langle G, \Sigma^G \rangle \)
is called a \emph{model} of \( \phi \)~\cite{book_parametrized_algorithms}.
%
To form atomic formulas in \MSO{}, we allow only following base predicates:
%
\begin{itemize}
	\item For \( u \) representing a vertex (edge) variable
	      and \( X \) is a vertex (edge) subset,
	      we can write formula \( u \in X \).
	      For \( G \), the formula is true if \( u^G \in X^G \) is true.
	\item Let \( u \) be a vertex variable and \( e \) be an edge variable,
	      then we can write formula \( \inc (u, e) \).
	      For \( G \), the formula is true if \( u^G \) is an endpoint of \( e^G \).
	\item For any two variables \( u, v \) of the same type, we can write \( u = v \).
	      For \( G \), the formula is true if \( u^G = v^G \).
\end{itemize}
%
We also allow simplifications like \( \ne, \not\in \).
As obvious from types of variables, we can quantify over vertices, edges,
subsets of vertices and subsets of edges.

It is beneficial to define auxiliary predicates to simplify our work.
We show examples taken from~\cite{book_parametrized_algorithms}.
First we show predicate \( \text{adj} \) represents if two vertices are adjacent.
%
\begin{align*}
	\text{adj}(u, v) \coloneqq (u \ne v) \land (\exists e \in E : \inc (u, e) \land \inc (v, e))
\end{align*}
%
For a graph \( G = (V, E) \), we can represent connectivity of its induced subgraph
on vertices \( X \subseteq V \) with the following predicate~\cite{book_parametrized_algorithms}.
%
\begin{align*}
	\text{connected}(X) \coloneqq \, &
	\forall Y \subseteq V : \Big(
	(
	\exists u \in X : u \in Y \land
	\exists v \in X : v \not\in Y
	)
	\\ &
	\Rightarrow
	(
	\exists u, v \in X : \text{adj}(u, v) \land u \in Y \land v \not\in Y
	)\Big).
\end{align*}
%
Notice that we used our previously defined predicate as an alias.
For \( X = V \), the formula would read as:
``For each separation of a graph, there exists an edge connecting both partitions''.

\subsection{Relation to treewidth}

In the following, for a formula \( \phi \) by \( \|\phi\| \)
we denote the length of the encoding of \( \phi \) as a string.
%
\begin{theorem}[Courcelle's theorem,~\cite{tree_width_mso,book_parametrized_algorithms}]%
	\label{theorem:courcelles_theorem}%
	Assume that \( \phi \) is a formula of \MSO{} and
	\( G \) is an \( n \)-vertex graph equipped
	with evaluation of all the free variables of \( \phi \).
	Suppose, moreover, that a tree decomposition of \( G \) of width \( k \) is provided.
	Then there exists an algorithm that verifies whether \( \phi \)
	is satisfied in~\( G \) in time \( f (\|\phi\|, k) \cdot n \),
	for some computable function \( f \).
\end{theorem}
%
If we are given an optimal tree decomposition, or we manage to find good enough
approximation, we know that we can decide any formula in \MSO{} in a time
polynomial in \( n \), but we are given no guaranties about the complexity of~\( f \).

\subsection{Expressing NAC-colorings using \( \text{MSO}_2 \)}

In this section we present results from our previous paper~\cite{my_paper}.
By \( V \) we denote the set of all vertices and
by \( E \) the set of all edges.
We start by defining other auxiliary predicates:
%
\begin{itemize}
	\item For a subset of edges \( F \) we define predicate
	      %
	      \begin{align*}
		      \text{deg2}(F) \coloneqq \predsp
		       & \forall e \in F \predsp \forall v \in V : \inc (v, e) \Rightarrow                                                                      \\
		       & \exists e' \in F \setminus \{e\} : \Big( \inc (v, e') \land \big(\forall e'' \in F \setminus \{e, e'\}: \lnot \inc (v, e'')\big)\!\Big).
	      \end{align*}
	      %
	      The predicate says that all vertices incident to edges in \( F \) have degree two.
	      %
	\item For a subset of vertices \( U \) and a subset of edges \( F \) we define predicate
	      %
	      \begin{align*}
		      \text{incident}(U, F) \coloneqq \predsp
		       & \big(\forall v \in U \predsp \exists e \in F : \inc (v, e)\big)                                                       \\
		       & \land \big(\forall e \in F \predsp \exists v_1, v_2 \in U : v_1 \ne v_2 \land \inc (v_1, e) \land \inc (v_2, e)\big).
	      \end{align*}
	      %
	      The predicate says that \( U \) are vertices of the subgraph induced by \( F \)
	      and that \( F \) are edges of the subgraph induced by \( U \),
	      e.g. \( (U, F) \) is an induced subgraph of \( (V, E) \).
	      %
	\item For a subset of edges \( F \) we define predicate
	      %
	      \begin{align*}
		      \text{cycle}(F) \coloneqq \predsp
		      \big( \exists X \subseteq V : \text{incident}(X, F) \land \text{connected}(X) \big)
		      \land \text{deg2}(F).
	      \end{align*}
	      %
	      The predicate says that edges \( F \) form a cycle.
	      %
	\item For subsets of edges \( F_1, F_2 \) we define predicate
	      %
	      \begin{align*}
		      \text{partition}(F_1, F_2) \coloneqq \predsp
		       & (\exists e_1, e_2 \in E : e_1 \in F_1 \land e_2 \in F_2 )    \\
		       & \land (\forall e \in E : e \in F_1 \lor e \in F_2 )          \\
		       & \land (\forall e \in E : e \not\in F_1 \lor e \not\in F_2 ).
	      \end{align*}
	      %
	      The formula reads as: ``Both the partitions are not empty,
	      and each edge is in exactly one of the partitions''.
	\item For subsets of edges \( C, F_\red, F_\blue \) we define predicate
	      %
	      \begin{align*}
		      \text{NACcond}(C, F_\red, F_\blue) \coloneqq \predsp
		       & C \subseteq F_\red \lor C \subseteq F_\red
		      \\
		       & \lor (\exists e_1, e_2, e_3, e_4 \in E :
		      e_1 \ne e_2 \land e_3 \ne e_4
		      \\
		       & \qquad \land e_1, e_2 \in F_\red \land e_3, e_4 \in F_\blue ).
	      \end{align*}
	      %
	      The predicate says that the cycles \( C \) is not an almost cycle.
	      %
\end{itemize}
%

With the predicates ready, we can proceed approach to the theorem.
%
\begin{theorem}[\cite{my_paper}]
	The problem of existence of a NAC-coloring is fixed-parameter
	tractable when parameterized by treewidth.
\end{theorem}
%
\begin{proof}
	We can express the NAC-coloring problem
	as a formula \( \phi \) in \MSO{} as follows:
	%
	\begin{align*}
		\exists E_\red, E_\blue \subseteq E : \,
		 & \text{partition}(E_\red, E_\blue)                                                                 \\
		 & \land \big(\forall C \subseteq E : \text{cycle}(C) \land \text{NACcond}(C, E_\red, E_\blue) \big)
		.
	\end{align*}
	%
	By \Cref{theorem:courcelles_theorem},
	there exists an FPT algorithm parameterized by treewidth
	that can resolve \( \phi \) and therefore resolve the question whenever a graph has a NAC-coloring.
\end{proof}
%
The proof shows us that there exists such an algorithm,
but it does not give us explicit steps to follow
(even tough they can be deduced from the original proof of \Cref{theorem:courcelles_theorem}).
Still, the complexity guaranties of the algorithm are not very clear.
In the following section we define our
own FPT algorithm that solves the NAC-coloring problem
while not relying on~\MSO{}.



\section{FPT algorithm}

In this section, we first introduce the core idea of
our FPT algorithm for NAC-coloring counting,
define a cache function,
show and prove the recursive formulas for the cache function for each node in a tree decomposition
and determine the complexity of the algorithm.
Lastly, we propose optimizations to the algorithm by also empowering monochromatic classes.


\subsection{The algorithm}

Our algorithm is slightly similar to Steiner tree search algorithm
as described in~\cite{book_parametrized_algorithms} as both the problems require connectivity
among vertex partitions. Unlike in the Steiner tree search algorithm,
our state space is even larger and all the state mapping operations are significantly different.

Before we start, we define some terms that come useful later.
When we talk about a component, we mean a connected component.
%
\begin{definition}[Connector, Neighboring components]
	For a graph \( G \) with a \rbcol{} \( \gamma \)
	and two distinct components of \( G[\Ered] \), resp.\ \( G[\Eblue] \),
	with vertex sets \( U_1 \) and \( U_2 \),
	a \emph{connector} is an edge \( e = \{u_1, u_2\} \in E(G) \)
	such that \( u_1 \in U_1 \) and \( u_2 \in U_2 \).
	%
	The components are \emph{neighboring} if there exists
	a connector for these two components.
\end{definition}
%

First we want to build the intuition for the upcoming operations.
Let us have a graph \( G \) and all NAC-colorings of the graph \( \nac{G} \).
Let us add an edge \( e = \{u, v\}, e \not\in E(G) \) to form the graph~\( G' \).
We want to obtain \( \nac{G'} \) based on \( \nac{G} \).
%
Let us have \( \delta \in \nac{G} \),
we want to extend it to \( \delta' \) where w.l.o.g.\ \( \delta'(e) = \blue \).
Coloring \( \delta' \) is a NAC-coloring unless an almost cycle is formed in \( G' \).
In that case one of the following cases must be true:
%
\begin{itemize}
	\item Both vertices \( u, v \) are in the same component in \( G[\Ered] \).
	      An almost cycle is formed
	      from \( \red \) \( u \)-\( v \)-path in the component
	      and edge \( e \) with \( \blue \) color.
	\item Vertices \( u, v \) lay in neighboring components in \( G[\Eblue] \)
	      i.e.\ there is a \( \red \) connector between the components.
	      An almost cycle is formed from \( \blue \) paths in each component,
	      the \( \red \) connector and \( \blue \) edge \( e \).
\end{itemize}
%
In all other cases, an almost cycle cannot be formed by adding a \( \blue \) edge \( e \).
Note that a vertex cannot be in multiple component for the given color
as this fact would mean that the components are not maximal.

To create \( \nac{G'} \), we extend the colorings
in \( \nac{G} \cup \{ \delta_\red \} \), where \( \delta_\red \)
colors all the edges in \( G \) with \( \red \) color.
We do the whole checking process likewise
for \( e \) colored \( \red \) --- all the colors used get swapped.
Then we keep only the surjective colorings that did not form an almost cycle.

We define an \emph{almost NAC-coloring}
as a \rbcol{} such that there are no almost cycles formed.
The conditions are the same as for NAC-coloring
except that the surjectivity requirement is dropped.
By \( \anac{G} \), we denote the set of all almost NAC-colorings of \( G \).
We use the notion of almost NAC-coloring for the rest of the section.
Later when output is read in a \RootNode{},
based on the number of all almost NAC-colorings of~\( G \)
the number of all NAC-colorings of~\( G \) is obtained.
Note that a graph with no edges has no almost NAC-colorings.

We use \emph{dynamic programming}, a well-known technique for solving problems
where the problem can be subdivided into smaller sub-problems.
Usually, some base cases are solved trivially and then a sub-problem
is solved based on the solution of its smaller sub-problems.
%
Often it is a case, that a smaller sub-problem would be solved multiple times
as it is a part of multiple larger sub-problems.
Its first result is therefore cached and reused
reducing the total running time significantly.
%
In other cases like ours it is a nice approach how to traverse
some data structure like matrix or a tree.
%
There are many popular dynamic programming algorithms
like \textsc{Edit Distance}, \textsc{Matrix Chain Multiplication} or \textsc{Longest Common Subsequence}.

In the following sections,
we work with a nice tree decomposition \( T \) of width \( k \)
of a graph \( G \).
%
We define a state space \( S \) of \emph{states}
that will be used by our cache in our dynamic programming algorithm.
We denote all partitions of a nonempty set \( X \) by \( \mathcal{F}(X) \),
and we put \( \emptyset = \mathcal{F}(\emptyset) \).

%
\begin{definition}[State space]
	Let \( t \in T \) be a node in the nice tree decomposition tree and
	\( X_t \) be its bag of vertices.
	%
	A \emph{state} is formed by a tuple \( s = (P_\red, R_\red, P_\blue, R_\blue) \)
	where \( P_\red, P_\blue \in \mathcal{F}(X_t)\) are partitions of \( X_t \),
	and \( R_\red\), resp.\ \(R_\blue \), is a symmetric irreflexive relation
	on parts in \( P_\red\), resp.\ \(P_\blue \).
	%
	All such states on \( X_t \) form the \emph{state space} \( S_t \).
\end{definition}
%
For some \( t \in T \), a \rbcol{} \( \gamma \) of \( G_t \)
is \emph{consistent} with a state \( s_t = (P_\red, R_\red, P_\blue, R_\blue) \in S_t \)
if \( \red \) and \( \blue \) components of \( \gamma \) form \( P_\red \) and \( P_\blue \)
when \( u, v \in X_t \) are in the same part in \( P_\red \) or \( P_\blue \)
if and only if they are in the same \( \red \) or \( \blue \) component induced by \( \gamma \).
There are connectors between two components if and only if
the corresponding parts are in relation \( R_\red \) or \( R_\blue \).
%
Note that we define consistence for general \rbcol{}s,
but usually we use them with almost NAC-colorings only.
%
Two parts are \emph{neighboring} if their corresponding components are neighboring.
When we talk about \emph{\( \red \) half of a state},
we mean \( P_\red \) and \( R_\red \),
analogically for \( \blue \).
%
Note that the state space is somewhat large,
we elaborate on the size in the proof of~\Cref{thm:fpt_algo}.
%
\begin{observation}
	For each \rbcol{} \( \gamma \) on \( G_t \),
	there is single state \( s \in S_t \) consistent with it.
	Multiple \rbcol{} can be consistent with a single state.
\end{observation}
%

In a dynamic programming algorithms, a cache function is gradually computed
from the simplest sub-problems to the largest ones.
Here, we have a function that already has all the values computed,
and we show relations for neighboring nodes in \( T \).
There recursive relations can be then used in an implementation.
%
\begin{definition}[Cache function]
	For a nice tree decomposition \( (T, \{X_t\}) \) on a graph \( G \),
	a \emph{cache function} \( c: \mathcal{S} \to \N_0 \)
	where \( \mathcal{S} = \{ (t,s): t \in T \in S_t \} \)
	is the function that maps \( (t, s) \)
	to the number of almost NAC-colorings of \( G_t \) consistent with \( s \).
\end{definition}
%
For the following definitions, lemmas, proofs and theorems, let us fix
a nice tree decomposition \( T \) of a graph \( G \) and width \( k \)
and a cache function \( c \) on \( T \).
%
\begin{lemma}%
	\label[lemma]{lemma:state_space_sum}
	%
	For \( t \in T \) and a graph \( G_t \),
	it holds that \( |\anac{G_t}| =  \sum_{s \in S_t} c[t, s] \).
\end{lemma}
%
\begin{proof}
	%
	For each~\( \delta \in \anac{G_t} \),
	there is a single state \( s \in S_t \) consistent with~\( \delta \).
	Therefore, if we sum over all states \( s \in S_t \),
	we consider every~\( \delta \in \anac{G_t} \) and get \( |\anac{G_t}| \).
\end{proof}
%
\begin{observation}
	For two nodes \( t_1, t_2 \in T \) such that \( G_{t_1}, G_{t_2} \)
	are isomorphic up to isolated vertices,
	then for bags \( X_{t_1}, X_{t_2} \) and state spaces \( S_{t_t}, S_{t_2} \),
	it holds that \( \sum_{s \in S_{t_1}} c[t_1, s] = \sum_{s \in S_{t_2}} c[t_2, s] \).
\end{observation}
%
% \begin{proof}
% 	Isolated vertices are not important for almost NAC-colorings
% 	as we consider edges only.
% 	Therefore, as \( |\anac{G_{t_1}}| = |\anac{G_{t_2}}| \),
% 	by \Cref{lemma:state_space_sum}
% 	it holds that \( \sum_{s \in S_{t_1}} c[t_1, s] = \sum_{s \in S_{t_2}} c[t_2, s] \).
% \end{proof}
%

In the following lemmas, we show recursive relations for \( c \) that must hold
for neighboring nodes in \( T \).
%
In the following proofs,
we often describe states that cannot be consistent with
any almost NAC-colorings and hence have zero value in \( c \).

We prove correctness of our algorithms by induction.
The base case is for \LeafNode{}s, for other nodes we split the reasoning for cases where
there is or is not at least one edge in \( G_t \).
%
Following lemmas always show mapping from child node \( t' \) states \( S_{t'} \)
to parent node \( t \) states \( S_t \).
We extend almost NAC-colorings on \( G_{t'} \) and
map which states in \( S_{t'} \) map to which state in \( S_t \)
or produce an almost cycle when extended.
%
For a color \( a \in \{\red, \blue\} \),
we define \( \bar{a} \) to be the opposite color.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Leaf node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{\LeafNode{}}

\begin{lemma}%
	\label[lemma]{lemma:fpt_leaf_node}
	%
	Let us have a \LeafNode{} \( t \in T \).
	It holds that \( c[t, s] = 0 \) for all \( s \in S_t \).
\end{lemma}
%
\begin{proof}
	There are no edges in \( G_t \) as there are no vertices
	neither in \( X_t \) nor \( V_t \).
	By definition of the cache function,
	\( c \) must hold \( 0 \) for each state of a \LeafNode{}.
\end{proof}
%
Note that for a \LeafNode{} \( t \in T \),
the only state in \( S_t \) is \( (\emptyset, \emptyset, \emptyset, \emptyset) \)
as \( X_t = \emptyset \).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduce Vertex Node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{\IntroduceVertexNode{}}

\newpage
\begin{lemma}%
	\label[lemma]{lemma:fpt_introduce_vertex_node}
	%
	Let an \IntroduceVertexNode{} \( t \in T \) be
	the only parent of \( t' \in T \).
	Let \( v \) be the only vertex in \( X_t \setminus X_{t'} \).
	%
	If there is no edge in the graph \( G_t \), then \( c[t, s] = 0 \) for each \( s \in S_t \).
	%
	Otherwise, the cache function \( c \) satisfies for
	\( s=(P_\red, R_\red, P_\blue, R_\blue) \in S_t \) the following:
	%
	\begin{align*}
		c[t, s] & =
		\begin{cases}
			0,         & \text{if } \exists a \in \{\red, \blue\} : \{v\} \not\in P_a,                    \\
			0,         & \text{if } \exists a \in \{\red, \blue\} \exists p \in P_a : (\{v\}, p) \in R_a, \\
			c[t', s'], & \text{otherwise},
		\end{cases}
	\end{align*}
	where
	\begin{align*}
		s' & \coloneqq (P_\red \setminus \{\{v\}\}, R_\red, P_\blue \setminus \{\{v\}\}, R_\blue).
	\end{align*}
\end{lemma}
%
The state \( s' \) represents the state where \( v \) is not present in any part
and where the same parts stay neighbors as in \( s \).
%
\begin{proof}
	By definition, there are no almost NAC-colorings
	in \( G_t \) if \( G_t \) has no edges,
	therefore \( c[t, s] = 0 \) for each \( s \in S_t \).
	%
	Otherwise, if vertex \( v \) is in a part of \( P_\red \) or \( P_\blue \) with other vertices,
	the cache function must be zero as \( v \) is an isolated vertex in \( G_t \)
	and therefore no almost NAC-coloring consistent with such state exists.
	Otherwise, there must be a part \( \{v\} \).
	%
	Also, as \( v \) is an isolated vertex in \( G_t \), there cannot be a connector
	connecting this and another component.
	Thus, for all states where there exists
	a part neighboring \( \{v\} \), there are no consistent almost NAC-colorings
	and therefore the cache function must be also zero.
	%
	For an almost NAC-coloring \( \delta \) on \( G_{t'} \) consistent with
	a state \( s' \in S_{t'} \),
	by adding part \( \{v\} \) to \( P_\red' \) and \( P_\blue' \)
	we get some \( s \in S_t \) that is also consistent with \( \delta \) in \( G_t \).
	Adding and removing part \( \{v\} \) is a bijective operation in this context.
	Therefore, \( c[t, s] = c[t', s'] \) holds for all states.
	%
	We have \( anac{G_t} = anac{G_{t'}} \) since \( E(G_t) = E(G_{t'}) \).
	Each almost NAC-coloring is consistent
	with \( s \) and \( s' \) given as described.
\end{proof}
%
To summarize, values from child node are propagated to the states
where \( v \) is added and stays isolated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Forget Vertex Node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{\ForgetVertexNode{}}

\begin{lemma}%
	\label[lemma]{lemma:fpt_forget_vertex_node}
	%
	Let a \ForgetVertexNode{} \( t \in T \) be
	the only parent of \( t' \in T \).
	Let \( v \) be the only vertex in \( X_{t'} \setminus X_t \).
	%
	If there are no edges in the graph \( G_t \),
	then \( c[t, s] = 0 \) for each \( s \in S_t \).

	Otherwise, the cache function for \( s=(P_\red, R_\red, P_\blue, R_\blue) \in S_t \)
	satisfies that:
	%
	\begin{align*}
		c[t, s] & = \sum_{s' \in S'} c[t', s'],
	\end{align*}
	where for \( a \in \{\red, \blue\} \)
	\begin{align*}
		d(p)               & \coloneqq p \setminus \{v\},                                                                                   \\
		D(P)               & \coloneqq \{d(p) \mid p \in P \} \setminus \{\emptyset\},                                                      \\
		\mathcal{P'}_a     & \coloneqq \{ P_a' \in \mathcal{F}(X_{t'}) \mid D(P_a') = P_a \},                                               \\
		\mathcal{R'}(P_a') & \coloneqq \{ R_a' \subseteq P_a' \times P_a' \mid \forall (p_1, p_2) \in R_a' :                                \\
		                   & \qquad (d(p_1), d(p_2)) \in R_a \lor d(p_1) = \emptyset \lor d(p_2) = \emptyset \},                            \\
		S'                 & \coloneqq \{(P_\red', R_\red', P_\blue', R_\blue') \mid P_a' \in \mathcal{P'}_a, R' \in \mathcal{R'}(P_a') \}.
	\end{align*}
\end{lemma}
%
Recall that \( R_\red, R_\blue \) are relations --- sets of pairs.
By \( d(p) \) we denote deletion of  the vertex \( v \) from a part \( p \),
and by \( D(P) \) we denote deleting the vertex \( v \) from all the parts in partition \( P \)
--- if \( \{v\} \in P \), \( \emptyset \) is also cleared.
Set \( \mathcal{P'}_a \) denotes all the partitions
such that removing \( v \) from them gives \( P_a \).
Mapping \( \mathcal{R'}(P_a') \) denotes all the relations \( R_a' \)
for \( P_a' \in \mathcal{P'}_a \) that correspond with \( R_a \) when \( v \) is removed
--- parts are updated or relations to \( \{v\} \) is removed.
States \( S' \subseteq S_{t'} \) is the set of all states that
correspond to state \( s \) when \( v \) is removed.
%
\begin{proof}
	If there are no edges in \( G_t \), none are added by a \ForgetVertexNode{}.
	Therefore, \( c[t, s] = 0 \) for all \( s \in S_t \).
	%
	Otherwise, we know that \( G_t = G_{t'} \).
	%
	For \( s \in S_t \),
	let us have an almost NAC-coloring \( \delta \) consistent with \( s \).
	We show all states in \( S_{t'} \) that may be consistent with \( \delta \).
	We show how w.l.o.g.\ \( \blue \) half of \( s' \in S_{t'} \) looks
	based on \( \blue \) half of \( s \).

	Let \( v \) be in a \( \blue \) component \( C \) such that
	\( C \) corresponds to no part in \( P_\blue \).
	Then for \( s' \) it holds that \( \{v\} \in P_\blue' \).
	%
	Components neighboring in \( R_\blue \)
	are also neighboring in \( R_\blue' \), therefore \( R_\blue \subseteq R_\blue' \).
	%
	Component \( C \) may be neighboring with
	components corresponding to parts in \( P_\blue' \).
	% It cannot be specified with witch without deeper knowledge about \( \delta \),
	% hence we consider all possible relations.
	To cover all possible \( \delta \),
	we consider all possible relations \( R_\blue' \).

	Now let \( v \) in a component corresponding to a part \( p \in P_\blue \).
	Then part in \( P_\blue' \) correspond to the same components and the only
	change is that part \( p \) is replaced by \( p \cup \{v\} \).
	Neighboring relation is updated accordingly.

	By this we described \( \red \) and \( \blue \) halves of states in \( S_{t'} \)
	such that they are consistent with the same almost NAC-colorings as \( s \).
	We used exactly the same operations as in the statement of the lemma.

	When we consider all states in \( S_t \), we cover all almost NAC-colorings on \( G_t \)
	and hence also all states in \( S_{t'} \) must get \( s \in S_t \) to map to.

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% Old proof left for nostalgia reasons
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% Let us have \( \delta \in \anac{G_{t'}} \)
	% and a consistent state \( s' \in S_{t'} \).
	% In \( G_t \), \( \delta \) is consistent with a state \( s \in S_t \).
	% Note that components in \( G_t \) and \( G_{t'} \) are the same.
	% %
	% We now describe how w.l.o.g.\ \( \blue \) half of \( s \) looks
	% based on the \( \blue \) half of \( s' \).
	% The halves do not influence ech other here.
	% %
	% If \( \{v\} \) is a part in \( P_\blue' \),
	% it is no longer considered in \( P_\blue \),
	% therefore \( P_\blue' \setminus \{\{v\}\} = P_\blue \).
	% All pairs with \( \{v\} \) are removed from \( R_\blue' \).
	% %
	% If \( \{v\} \) is not a part in \( P_\blue' \),
	% \( v \) is in another part of \( P_\blue' \).
	% In \( P_\blue \), the parts look the same except they do not
	% contain \( v \). Relation \( R_\blue' \) is updated analogically.
	% %
	% Either of these statements hold for the \( \blue \) half,
	% analogically for the \( \red \) half.
	% %
	% The mappings we prove are exactly \( \mathcal{P'} \) and \( \mathcal{R'} \)
	% in the statement of the lemma.
	% %
	% We showed mapping for each \( s' \in S_{t'} \) into \( S_t \).
	% %
\end{proof}
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduce Edge Node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{\IntroduceEdgeNode{}}

When discussing \IntroduceEdgeNode{} introducing edge \( e \),
we first describe states in \( S_{t} \)
that cannot be consistent with any almost NAC-coloring in \( G_t \).
If they can, we call them \emph{allowed}, otherwise they are \emph{not allowed}.
Similarly, we define this notion for halves of a state.
%
An edge \emph{lies} in a part if both its endpoints are in the part.
An edge \emph{connects} two parts if its endpoints are each in one part.
%
We state conditions for extending almost NAC-coloring \( \delta' \)
consistent with \( s' \in S_{t'} \)
by an edge colored by one color first,
w.l.o.g.\ let the introduced edge \( e \) be colored \( \blue \).
%
To avoid confusion, note that in the following statements we assume
a state \( s \in S_t \) after the edge \( e \) is added, not a state \( s' \in S_{t'} \).
%
We first state conditions for \( \blue \) half of a state \( s \):
%
\begin{description}
	\item[Edge \( e \) lies in a \( \blue \) part]
	      In this trivial case, an almost cycle is not created in \( \blue \) components.
	      This is \emph{\( \blue \)-allowed}.
	      %
	\item[Edge \( e \) connects two neighboring \( \blue \) parts]
	      This causes an almost cycle to be created as
	      components corresponding to the parts
	      are now a single component.
	      Therefore, the state \( s \) does not describe
	      the actual state for any almost NAC-coloring in \( G_t \)
	      as there should be only a single part, and therefore this is \emph{not allowed}.
	      %
	\item[Edge \( e \) connects two non-neighboring \( \blue \) parts]
	      This is \emph{not allowed} as both parts
	      are now using this \( \blue \) edge and should be one part.
\end{description}
%
Now we state conditions for \( \red \) half of a state \( s \):
%
\begin{description}
	\item[Edge \( e \) lies in a \( \red \) part]
	      In this case, an almost cycle is trivially created
	      through the \( \red \) component,
	      therefore this is \emph{not allowed}.
	      %
	\item[Edge \( e \) connects two neighboring \( \red \) parts]
	      This is \emph{\( \blue \)-allowed} as \( e \) is a connector and
	      therefore the parts need to be neighboring.
	      %
	\item[Edge \( e \) connects two non-neighboring \( \red \) parts]
	      This state is \emph{not allowed} as both parts
	      are now neighboring as \( e \) is a connector.
	      This is \emph{not allowed}.
\end{description}
%
The same check is done analogically for \( \red \)-allowed.
A state is allowed if both its halves are \( \red \)-allowed or
both the halves are \( \blue \)-allowed.
Otherwise, a state is not allowed.

\begin{lemma}%
	\label[lemma]{lemma:fpt_introduce_edge_node}
	%
	Let us have an \IntroduceEdgeNode{} \( t \in T \) that is
	the only parent of \( t' \in T \).
	It holds that \( X_t = X_{t'} \),
	let \( e = \{u, v\} \) be the edge introduced by~\( t \), \( e \in Y_t \setminus Y_{t'} \).
	%
	If there is only a single edge \( e \) in \( G_t \)
	(the just introduced edge \( e \)) in \( E_t \),
	for each state \( s = (P_\red, R_\red, P_\blue, R_\blue) \in S_t \),
	the cache function satisfies that:
	\begin{align*}
		c[t, s] & =
		\begin{cases}
			1, & \text{if } \exists a \in \{\red, \blue\} :                                                 \\
			   & \{u\}, \{v\} \in P_a \land \{u, v\} \in P_{\bar{a}}                                        \\
			   & \land \, \{(\{u\}, \{v\}),(\{v\}, \{u\})\} = R_a \land R_{\bar{a}} = \emptyset             \\
			   & \land \, \forall z \in V_t \setminus \{u, v\} : \{z\} \in P_a \land \{z\} \in P_{\bar{a}}, \\
			0, & \text{otherwise}.
		\end{cases} \\
	\end{align*}
	%
	Otherwise, if the state \( s \) is not allowed, then \( c[t, s] = 0 \).
	%
	For an allowed state~\( s \),
	the only states \( s' = (P_\red', R_\red', P_\blue', R_\blue') \in S_{t'} \),
	such that almost NAC-colorings consistent with \( s' \) are extended
	to almost NAC-colorings consistent with \( s \) by adding \( \blue \) edge \( e \),
	are the states that fulfill these conditions for their both halves:
	%
	\begin{description}
		\item[Edge lies in a \( \blue \) part of \( s \)]
		      There are two possibilities for the \( \blue \) half of a state \( s' \).
		      %
		      The first is condition that \( P_\blue = P_\blue' \)
		      and \( R_\blue = R_\blue' \) must hold.
		      %
		      The other condition is that the endpoints of \( e \)
		      must be in different \( \blue \) parts \( p_1, p_2 \in P_\blue' \)
		      such that these parts are not neighboring, e.g.\ \( (p_1, p_2) \not\in R_\blue' \).
		      The other parts are the same as in \( P_\blue \),
		      except for part \( p = p_1 \cup p_2, p \in P_\blue \),
		      e.g.\ \( P_\blue' \setminus \{p_1, p_2\} = P_\blue \setminus \{p\} \).
		      \( R_\blue \) and \( R_\blue' \) must also match accordingly.
		      %
		      Either of the conditions has to be fulfilled.

		      % First we query the previous cache state with
		      % the same partition and neighbors state.
		      % Then we also need to add states where
		      % both the components were not neighbors as no almost cycle was created
		      % and both the separate components
		      % are now joined into a single component.
		      % We denote \( \blue \) components of such state
		      % as \( P_\blue' \) and \( R_\blue' \).
		      % Note, that other relations between partitions need to match.
		      %
		\item[Edge connects two neighboring \( \red \) parts of \( s \)]
		      There are two possibilities for the \( \red \) half of a state \( s' \).
		      %
		      The first condition is that \( P_\red = P_\red' \)
		      and \( R_\red = R_\red' \) must hold.
		      %
		      Now, let \( p_1, p_2 \in P_\red \) be the \( \red \) parts
		      of end vertices of \( e \).
		      The other condition is that \( P_\red = P_\red' \) and
		      \( R_\red \setminus \{(p_{1}, p_{2}), (p_{2}, p_{1})\} = R_\red' \) must hold.
		      %
		      Either of the conditions has to be fulfilled.

		      % Result is a sum of previous states with the same partitioning as \( P_\red \),
		      % for first query we use \( R_\red \),
		      % and then we add query of \( R'_\red = R_\red \setminus \{(c(u), c(v)), (c(v), c(u))\} \)
		      % (with the neighbor constraint removed).
	\end{description}
	%
	There are four distinct states \( s_1', s_2', s_3', s_4' \in S_{t'} \)
	that fulfil these conditions, one for each condition combination.
	%
	We define a function \( c_\blue \) that represents
	the number of all almost NAC-colorings
	consistent with state \( s \in S_t \) on \( G_t \)
	where \( e \) is colored \( \blue \).
	The value for \( c_\blue \) satisfies that:
	%
	\begin{align*}
		c_\blue[t, s] & = c[t', s_1'] + c[t', s_2'] + c[t', s_3'] + c[t', s_4'].
	\end{align*}
	%
	The same holds for \( \red \) analogously.
	Cache function satisfies that  \( c[t, s] = c_\red[t, s] + c_\blue[t, s] \).
\end{lemma}
%
\begin{proof}
	For the case when \( e \) is the only edge,
	there are exactly two almost NAC-colorings on \( G_t \).
	The states consistent with these colorings are \( s_\red \) and \( s_\blue \)
	such that if \( u, v \) are in the same part in \( P_\red \), resp.\ \( P_\blue \),
	there are parts \( \{u\}, \{v\} \) (singletons) in \( P_\blue \), resp.\ \( P_\red \),
	as these vertices cannot be yet connected by \( \blue \), resp.\ \( \red \), edges.
	Edge \( e \) is a connector, so there must be a corresponding neighboring
	relation \( (\{u\}, \{v\}) \in R_\blue \), resp.\ \( R_\red \).
	Other states are not consistent with any almost NAC-colorings.
	This is exactly what we describe in the lemma.

	Otherwise, only allowed states may have consistent almost NAC-colorings on \( G_t \).
	%
	For an almost NAC-coloring \( \delta' \) on \( G_{t'} \),
	by adding w.l.o.g.\ a single \( \blue \) edge \( e \),
	it is either extended to an almost NAC-coloring \( \delta \) on \( G_t \)
	or an almost cycle is created.

	Let \( f \) the only edge with a different color in the almost cycle.
	Let \( f \) be colored \( \red \).
	Then there is a \( \blue \) path connecting its endpoints using \( e \),
	as there was no such \( \blue \) path before.
	Therefore, there must be two \( \blue \) components \( p_1', p_2' \) in \( G_{t'} \)
	connecting endpoints of \( e \) to \( f \).
	Hence, \( f \) must be a connector connecting \( p_1' \) and \( p_2' \),
	and parts \( p_1' \) and \( p_2' \) are neighboring.
	But we do not consider such states in \( s_1', \dots, s_4' \).

	Let us now consider \( f \) is colored \( \blue \).
	Then \( e = f \) and
	there must be a \( \red \) path in \( G_{t'} \) connecting its endpoints.
	This path must be in a single \( \red \) component corresponding
	to a \( \red \) part \( p \in P_\red' \cap P_\red \).
	But we do not consider such states in \( s_1', \dots, s_4' \).

	Now we show what a state \( s \in S_t \) is
	for colorings consistent with \( s' \in \{s_1', \dots, s_4'\} \)
	when \( \blue \) edge \( e \) is added.
	%
	First we show the blue half.
	If \( e \) lies in a \( \blue \) part,
	both its endpoints are the same \( \blue \) component
	for \( \delta \) and the \( \blue \) components do not change.
	If \( e \) connects two non-neighboring \( \blue \) parts,
	then the \( \blue \) components merge. The same has to be reflected in
	the consistent state in \( S_t \).

	If \( e \) connects two \( \red \) components based on \( \delta \) in \( G_t \),
	they are neighboring now independently if they were or were not neighboring before.
	The \( \red \) components itself do not change.

	By this we showed that all almost NAC-colorings on \( G_{t'} \) consistent with
	states \( s_1', \dots, s_4' \) are extended to almost NAC-colorings on \( G_t \)
	consistent with \( s \) where \( e \) is colored \( \blue \).
	States \( s_1', \dots, s_4' \) are the only states in \( S_{t'} \) mapped to~\( s \).
	We also covered all states in \( S_{t'} \).
	%
	When the same is done for \( \red \), all the possible extensions
	of almost NAC-colorings on \( G_{t'} \) to almost NAC-colorings on \( G_t \)
	are covered.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Join node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection*{\JoinNode{}}

In the following paragraphs,
we first define term and prove lemmas
that come useful later in \Cref{lemma:fpt_join_node}.
%
Let us have a \JoinNode{} \( t \in T \) that is
the only parent of \( t_1', t_2' \in T \).
It holds that \( X_t = X_{t_1}' = X_{t_2}' \),
\( G_{t_1'} \ne G_{t_2'} \)
and \( S_t = S_{t_1'} = S_{t_2'} \)
(we abbreviate them to \( S, S_1', S_2' \)).
%
For two \rbcol{}s \( \gamma_1', \gamma_2' \)
on \( G_{t_1'} \) and \( G_{t_2'} \)
where \( E(G_{t_1'}) \cap E(G_{t_2'}) = \emptyset \),
the \emph{merge} of \( \gamma_1' \) and \( \gamma_2' \)
is a \rbcol{} \( \gamma : E(G_t) \to \{ \red, \blue \} \) on \( G_t \)
such that \( \forall e \in E(G_{t_1'}) : \gamma(e) = \gamma_1'(e) \) and
\( \forall e \in E(G_{t_2'}) : \gamma(e) = \gamma_2'(e) \).
%
For a state \( s \in S \), we find the set of
pairs \( (s_i', s_2') \in S_i' \times S_2' \),
whose consistent almost NAC-coloring are merged
to almost NAC-coloring consistent with \( s \).

First we define an operation that shows for two states \( s_1', s_2' \)
which state is consistent with coloring merged from \( s_1' \) and \( s_2' \).
%
\begin{definition}%
	\label[definition]{def:fpt_merging_map}
	%
	A \emph{merging map} \( M: S_1' \times S_2' \to S \)
	maps \( s_1', s_2' \) to the state \( s \)
	such that the almost NAC-colorings consistent with \( s_1' \) and \( s_2' \)
	merged together are \rbcol{}s consistent with \( s \).
\end{definition}
%
It may not be obvious that for every coloring pair consistent with \( s_1', s_2' \)
there is a singe state \( s \in S \) consistent with the merged \rbcol{}.
In the following construction we show that
only the parts of \( s_1', s_2' \) determine \( s \).
Later we filter out \rbcol{}s that contain an almost cycle.

Let \( R^* \) denote the reflexive-transitive closure of a relation \( R \).
For each \( i \in \{1, 2\} \), let us have states
\( s_i' = (P_{i,\red}', R_{i,\red}', P_{i,\blue}', R_{i,\blue}') \in S_i' \).
%
We process \( \red \) and \( \blue \) halves of the states separately.
For each \( a \in \{\red, \blue\} \),
we take equivalence relations \( O_{i, a}' \)
whole equivalence classes are the partitions \( P_{i, a}' \),
\( P_{i, a}' = \equivclass{X_t}{O_{i, a}'}\).
We set
%
\begin{equation}%
	\label{eq:fpt_reflexive_transitive_closure}
	\begin{aligned}
		O_a & \coloneqq {(O_{1, a}' \cup O_{2, a}')}^*, \\
		P_a & \coloneqq \equivclass{X_t}{O_a}.
	\end{aligned}
\end{equation}
%
This operation represents merging colored components from both the states
--- if multiple components intersect, they become one
component and therefore one part.

We continue with neighbors relation. We remove pairs of parts
that were merged and update the relations to correspond with the new parts.
For each \( i \in \{1, 2\} \) and for each \( a \in \{\red, \blue\} \) let
%
\begin{align*}
	R_{i,a} & \coloneqq \{(p_1, p_2) \in P_a \times P_a \mid p_{1} \ne p_{2} \, \land                                                 \\
	        & \qquad \exists p_1', p_2' \in P_{i,a}' : (p_1', p_2') \in R_{i,a}' \land p_1' \subseteq p_1 \land p_2' \subseteq p_2\},
\end{align*}
%
and let \( R_a \coloneqq R_{1,a} \cup R_{2,a} \).

\begin{lemma}%
	\label[lemma]{lemma:fpt_merging_map}
	%
	For a merging map \( M \), it holds that:
	\[ M(s_1', s_2') = (P_\red, R_\red, P_\blue, R_\blue). \]
\end{lemma}
%
\begin{proof}
	For each \( i \in \{1, 2\} \),
	let us have an almost NAC-colorings \( \delta_i' \) consistent with
	\( s_i' \) in \( G_{t_i'} \).
	We merge the two almost NAC-colorings \( \delta_1' \) and \( \delta_2' \)
	to obtain a \rbcol{} \( \gamma \) on \( G_t \).
	This is possible as \( Y_t = \emptyset \) for a \JoinNode{}.
	%
	Let us find colored components in \( G_t \) according to \(	\gamma \).
	The components have to be naturally the same or larger
	than the components in \( G_{t_1'} \) and \( G_{t_2'} \).
	%
	If two \( \blue \) components \( C_1', C_2' \),
	one from \( G_{t_1'} \) with \( \delta_1' \) and
	the other from \( G_{t_2'} \) with \( \delta_2' \),
	are merged into one \( \blue \) component \( C \) in \( G_t \),
	there must be a \( \blue \) path connecting them.
	The path must visit vertices \( p_1, \dots, p_l \in X_t \)
	and switch from \( \blue \) components in \( G_{t_1'} \)
	to \( \blue \) components in \( G_{t_2'} \) or the other way around.
	%
	The reflexive-transitive closure in \Cref{eq:fpt_reflexive_transitive_closure}
	ensures that all parts corresponding to visited \( \blue \) components
	get merged into common part \( p \in P_a \).
	This part naturally corresponds to the component \( C \) in \( G_t \).
	%
	If two components \( C_1, C_2 \) corresponding to
	parts \( p_1', p_2' \in P_{i,a}' \) in \( G_{t_i'} \) are neighboring,
	all the parts merged with them preserve the property
	(unless \( p_1' \) gets merged with \( p_2' \) to preserve irreflexivity).
	%
	Hence, \( s = M(s_1', s_2') \) is consistent with \( \gamma \).
\end{proof}

Now we define a notion of filtering out
merges that do not produce almost NAC-colorings.
%
\begin{definition}%
	\label[definition]{def:fpt_bad_states}
	%
	A pair \( (s_1', s_2') \in S_1' \times S_2'\) is \emph{bad}
	if almost NAC-colorings \( \delta_1', \delta_2' \)
	consistent with \( S_1 \) and \( S_2 \) are merged
	into \rbcol{} \( \gamma \) consistent with \( s = M(s_1', s_2') \),
	but an almost cycle is created in \( G_t \) considering \( \gamma \).
	%
	We denote the set of all bad states by \( \mathcal{B} \).
\end{definition}
%
\begin{lemma}%
	\label[lemma]{lemma:fpt_join_bad_states}
	%
	Let \( (s_1', s_2') \in S_1' \times S_2' \),
	\( s_i' = (P_{i,\red}', R_{i,\red}', P_{i,\blue}', R_{i,\blue}') \),
	and \( s = M(s_1', s_2')
	= (P_\red, R_\red, P_\blue, R_\blue) \in S_t \).
	For each \( a \in \{\red, \blue \} \),
	\( (s_1', s_2') \in \mathcal{B} \) if and only if
	there exists \( p \in P_{a} \)
	and \( P_{i, a}'' \subseteq P_{i, a}' \)
	such that \( \bigcup_{p' \in P_{i, a}''} p' = p \)
	and there exists \( p_1', p_2' \in P_{i, a}'' : (p_1', p_2') \in R_{i, a}' \).
\end{lemma}
%
\begin{proof}
	We show that \( (s_1', s_2') \) is not bad only if the state \( s \)
	can be consistent with any almost NAC-coloring on \( G_t \)
	merged from almost NAC-colorings on \( G_{t_1'} \) and \( G_{t_2'} \)
	consistent with states \( s_1' \) and \( s_2' \).

	For almost NAC-colorings \( \delta_1', \delta_2' \) on \( G_{t_1'}, G_{t_2'} \)
	consistent with \( s_1', s_2' \),
	we want to show how state \( s \in S \) looks and
	whether \rbcol{} \( \gamma \) created by merging \( \delta_1' \) and \( \delta_2' \)
	is an almost NAC-coloring.
	We show that this only depends on the states \( s_1', s_2' \),
	not on the structure of \( \delta_1' \) and \( \delta_2' \).

	% If there exists an almost cycle => the described checks hold
	First, let us go through cases how can an almost cycle be created.
	%
	Suppose \( f \) is the only edge with different color
	in an almost cycle and let it be w.l.o.g.\ colored \( \red \).
	Then there must exist a \( \blue \) path connecting its endpoints.
	W.l.o.g.\ let \( f \in E_{t_1'} \).
	%
	If the path spans only vertices
	in \( V_{t_1'} \), \( \delta_1' \) is not an almost NAC-coloring.
	%
	Therefore, \( f \) must be
	a connector connecting two \( \blue \) components \( p_1', p_2' \in P_{1,\blue} \),
	and the path has to also visit multiple vertices in \( V_{t_2'} \).
	As shown in the proof of the merging map \( M \), \( \blue \) components
	visited by such path are merged together.
	%
	Such an almost cycle therefore occurs
	if and only if \( p_1' \) and \( p_2' \) are neighboring in \( R_{1,\blue}' \),
	and they get merged to \( p \in P_\blue \).
	These are the only possibilities how an almost cycle can be created.
	%
	If also done for almost cycles with a \( \blue \) edge,
	these are exactly the bad states.
	%

	% If the described properties hold => there is an almost cycle
	For the other direction we show that if \( (s_1', s_2') \in \mathcal{B} \),
	there exists an almost cycle
	in \rbcol{} \( \gamma \) consistent with \( s = M(s_1', s_2') \)
	merged from almost NAC-colorings \( \delta_1' \) and \( \delta_2' \)
	consistent with \( s_1', s_2' \).
	%
	As \( (s_1', s_2') \in \mathcal{B} \),
	there exist \( p_1', p_2' \in P_{i, a}'' : (p_1', p_2') \in R_{i, a}' \),
	such that \( (p_1', p_2') \in R_{i, a}' \).
	There also exists \( p \in P_{a} \) such that \( \bigcup_{p' \in P_{i, a}''} p' = p \).
	This means that there exists a connector \( \{u, v\} \) colored \( \bar{a} \) connecting
	components corresponding to \( p_1' \) and \( p_2' \).
	As \( p_1', p_2' \subseteq p \),
	their components on \( G_{t_i'} \) are now merged
	to a component \( C \) on \( G_t \) colored \( a \) corresponding to \( p \).
	Then there exists a \( u \)-\( v \)-path in \( C \) colored \( a \).
	An almost cycle is created from this path and the connector \( \{u, v\} \).
\end{proof}
%

Now we show the recursive constraint of the cache function \( c \) for \JoinNode{}s.
%
\begin{lemma}%
	\label[lemma]{lemma:fpt_join_node}
	%
	Let us have a \JoinNode{} \( t \in T \) that is
	the only parent of \( t_1', t_2' \in T \),
	merging map \( M \),
	and bad states \( \mathcal{B} \).

	If both \( G_{t_1'} \) and \( G_{t_2'} \) have no edges,
	then \( c[t, s] = 0 \) for each \( s \in S \).
	If only one of \( G_{t_1'} \) and \( G_{t_2'} \) has no edges,
	w.l.o.g.\ let \( G_{t_1'} \) have no edges,
	then \( c[t, s] = c[t_2', s] \) for each \( s \in S \).
	%
	Otherwise, both \( G_{t_1'} \) and \(G_{t_2'} \) have some edges.
	Then for the cache function \( c \) it holds that:
	%
	\begin{align*}
		c[t, s] & = \sum_{(s_1', s_2') \in \mathcal{S}(s) \setminus \mathcal{B}} c[t_1', s_1'] \cdot c[t_{2}', s_{2}']
	\end{align*}
	where
	\begin{align*}
		\mathcal{S}(s) & \coloneqq \{(s_1', s_2') \in S_{t_1'} \times S_{t_2'} \mid M(s_1', s_2') = s \}.
	\end{align*}
	%
\end{lemma}
%
% The formula for the cache function comes from
% the same idea as the Cartesian product and
% NAC-product (\Cref{def:NACproduct}).
% The size of such products is multiple of the numbers of
% almost NAC-colorings on \( G_{t_1'} \) and \( G_{t_2'} \).
%
\begin{proof}
	By \Cref{def:fpt_merging_map}
	\( \mathcal{S}(s) \) is a set of
	all pairs of states in \( S_{t_1'} \times S_{t_2'} \)
	such that almost NAC-colorings consistent with \( s_1' \) and \( s_2' \)
	are merged to \rbcol{}s consistent with \( s \).
	As shown in \Cref{lemma:fpt_join_bad_states},
	these \rbcol{}s are almost NAC-colorings consistent with \( s \)
	when we do not consider bad states \( \mathcal{B} \).
	%
	For each pair of almost NAC-colorings \( \delta_1', \delta_2' \)
	consistent with \( s_1', s_2' \) such that \( (s_1', s_2') \) is not bad,
	there is one almost NAC-coloring~\( \delta \) consistent with \( s \)
	obtained by merging \( \delta_1' \) and \( \delta_2' \).
	There are \( c[t_1', s_1'] \cdot c[t_2', s_2'] \) such coloring pairs and
	when we sum over all such states in \( \mathcal{S}(s) \setminus \mathcal{B} \)
	we get that \( c[t, s] \ge c[t_1', s_1'] \cdot c[t_2', s_2'] \).
	%
	For the opposite inequality, assume that we have
	an almost NAC-coloring \( \delta \) on \( G_t \) consistent with \( s \)
	that is not accounted for by merging some \( \delta_i' \).
	But a restriction of \( \delta \) onto \( G_{t_i'} \) produces an almost NAC-coloring
	consistent with \( s_i' \) for each \( i \in \{1,2\} \).
	This concludes the statement.
\end{proof}
%

\subsubsection*{\RootNode{}}

%
\begin{lemma}%
	\label[lemma]{lemma:fpt_root_node}
	Let us have a \RootNode{} \( r \in T \) with unique child \( t' \).
	Then \( c[r, (\emptyset,\emptyset,\emptyset,\emptyset)] = c[t', (\emptyset,\emptyset,\emptyset,\emptyset)] \).
\end{lemma}
%
\begin{proof}
	The cache function \( c \) holds for \( t' \) the number of almost NAC-colorings on \( G_{t'} \).
	As \( G_{t'} = G_r \), the number of almost NAC-colorings on \( G_r \) is the same.
	Also, as \( X_t = \emptyset \), the only state in \( t \) and \( t' \) are as stated.
\end{proof}
%

\subsubsection*{All done}

%
\begin{theorem}%
	\label[theorem]{thm:fpt_algo}
	%
	There exists an FPT algorithm
	that for a given nice three decomposition \( T \) of \( G \)
	can find the number of NAC-colorings of \( G \) in time
	\( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot O(n) \), where \( n \) is the number of vertices of \( G \)
	and \( k \) is the width of \( T \).
\end{theorem}
%
\begin{proof}
	We compute values of the cache function on \( T \) in a bottom-up manner
	by using recursive formulas from
	\Cref{%
		lemma:fpt_leaf_node,%
		lemma:fpt_introduce_vertex_node,%
		lemma:fpt_forget_vertex_node,%
		lemma:fpt_introduce_edge_node,%
		lemma:fpt_join_node,%
		lemma:fpt_root_node%
	}.
	We read the output of the \RootNode{} \( r \) as follows:
	%
	\begin{align*}
		\text{output} \coloneqq \max\{c[r, (\emptyset,\emptyset,\emptyset,\emptyset)] - 2, 0\}.
	\end{align*}
	%
	This gives us the number of NAC-colorings of \( G \) as \( G = G_r \).
	If the graph has no edges, we read \( 0 \), that is why we use \( \max{} \) in the reading.
	By definition, cache function \( c \) always stores the number of almost NAC-colorings.
	There are only two almost NAC-colorings
	that are not NAC-colorings (the monochromatic ones) an they get subtracted.
	Based on that it can be clearly seen that the algorithm
	will never give you up~\cite{never_gonna_give_you_up}.

	Bell numbers are defined as
	the number of partitions of a set with \( n \) elements.
	They can be upper bounded by \( n^n \), which is what we use from now on.
	Recall that \( \forall t \in T : |X_t| \le k+1 \).
	%
	First, the size of the state space used is upper bounded.
	For each color there is up to \( {(k+1)}^{(k+1)} \) partitions of a bag and
	up to \( 2^{\binom{k}{2}} \) neighboring relations.
	The total state space size for each bag is therefore bounded by
	\[ {\Big({(k+1)}^{(k+1)} \cdot 2^{\binom{k}{2}} \Big)}^2 = {(k+1)}^{2(k+1)} \cdot 2^{2 \binom{k}{2}}. \]

	We assume the cache function lookups and stores have constant time complexity.
	We go through all the nodes and state complexity of the operations performed in node:
	%
	\begin{description}
		\item[\IntroduceVertexNode{}]
		      We need to fill a state space and copy previous values into the cache
		      which can be done in constant time per operation,
		      so the time complexity corresponds to the state space size:
		      \( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot O(1) \).
		\item[\ForgetVertexNode{}]
		      Although the operation seams complex, we just need to traverse the state space
		      and create target state after \( v \) is removed.
		      This can be done in \( O(k) \) time
		      per state as only neighboring relations where \( v \) is present
		      need to be also updated.
		      The total complexity therefore is
		      \( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot O(k) \).
		\item[\IntroduceEdgeNode{}]
		      The state space is iterated again, and we run few simple checks and cache key constructions
		      that can be run in \( O(k) \) time, therefore the final complexity stays the same
		      \( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot O(k) \).
		\item[\JoinNode{}]
		      We iterate through product of state spaces,
		      so the size of the new state space is the power of two
		      of the otherwise used state space size.
		      This hides into the big \( O \) notation.
		      Checks for almost cycles can be run in time \( O(k^2) \).
		      Thus, the final complexity is
		      \( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot O(k^2) \).
	\end{description}
	%
	There are \( O((n+m)k) \) nodes in \( T \) where \( m \) is bounded by \( O(kn) \).
	The final complexity of the algorithm is therefore
	\( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot O(n) \).
\end{proof}
%

\subsection{\IntroduceVertexWithEdgesNode{}}

As we also mentioned before, FPT algorithms parameterized by treewidth
often use \IntroduceVertexNode{} in such a way
that edges incident to the introduced vertex and to
the vertices in the bag are also considered.
For this section, we call such behaving node an \IntroduceVertexWithEdgesNode{}.
%
We base our approach on the lemmas from the previous section.
We outline the proof of correctness of such operation and show
that it is actually asymptotically slower than the originally proposed algorithm.

We consider a nice tree decomposition \( T \) as defined originally
with no \IntroduceEdgeNode{}s.
The lemmas for
\LeafNode{}, \RootNode{} and \ForgetVertexNode{} hold with no changes.
%
In the proof of lemma \Cref{lemma:fpt_join_node}
regarding \JoinNode{},
we used the fact that \( Y_t = \emptyset \).
This is not a necessary requirement.
%
Let us have almost NAC-colorings \( \delta_1' \) and \( \delta_2' \)
consistent with states \( s_1' \in S_{t_1'} \) and \( s_2' \in S_{t_2'} \)
such that \( f \in Y_t \) is colored w.l.o.g.\ \( \red \) in \( \delta_1' \)
and \( \blue \) in \( \delta_2' \).
But then \Cref{lemma:fpt_merging_map}
still detects this pair as a bad state
as \( f \) is a \( \red \) connector in a (new) \( \blue \) connected component.

Let us describe the idea how \IntroduceVertexWithEdgesNode{} works.
Before, when a single edge was added,
we checked if there is some constraint violation
--- if an almost cycle was formed.
The same is also done for \IntroduceVertexWithEdgesNode{},
but you can think of the process as
multiple such constrains checks at the same time.

Let us have an \IntroduceVertexWithEdgesNode{} \( t \in T \) that
is the only parent of \( t' \in T \).
Let \( v \) be the only vertex in \( X_t \setminus X_{t'} \).
Let \( F \) be the newly considered edges,
\( F = \{ \{ u, v \} \mid u \in X_t \} \cap E(G) \).
%
Let us have a set \( \Lambda \) of all almost NAC-colorings on \( F \)
(trivially found for a star), \( |\Lambda| = 2^{|F|} \).
Let us have a state space \( S_\Lambda \) on \( G_F \coloneqq G_t[F] \)
and bag \( X_F \coloneqq V(G_F) \setminus \{ v \} \).
%
\begin{observation}
	A state in \( S_\Lambda \) is consistent with at most one
	almost NAC-coloring in \( \Lambda \).
	%
	For each \( a \in \{\red, \blue\} \) and
	each \( s_\lambda = (P_\red, R_\red, P_\blue, R_\blue) \in S_\Lambda \)
	and \( \lambda \in \Lambda \) consistent with \( s_\lambda \),
	%
	if \( \lambda \) is not monochromatic,
	\( \exists p_a \in P_a : |p_a| > 1
	\land \forall p_a' \in P_a \setminus \{p_a\} : |p_a'| = 1 \)
	and for each \( x \in X_F \), either \( x \in p_\red \) or \( x \in p_\blue \) holds.
	%
	If \( \lambda \) is monochromatic, \( \exists p_a \in P_a : |p_a| = |F| \).
\end{observation}
%
This can be seen from the fact that \( G_F \) is a star and \( X_F \) are its rays.
If there are two components of the same color,
they both must span \( v \)
and therefore they are not maximal.

Hence, from now on by \( S_\Lambda \) we only consider states corresponding to
an almost NAC-coloring in \( \Lambda \), hence \( |S_\Lambda| = |\Lambda| \).
%
Let us have%
\nohznamka{
	Technically, these lemmas should be adapted for the fact that state space \( S_\Lambda \)
	does not come from a node in \( T \). This is just a technicality
	as we have vertex bag \( C_F \), edge bag \( F \) and graph \( G_F \)
	and only these are needed for mentioned definitions and proofs of corresponding lemmas.
	Also, isolated vertices \( X_t \setminus X_F \) should to be added to \( G_F \).
	We skip this as this is not the main important part of the algorithm.
}
merging map (\Cref{def:fpt_merging_map})
\( M : S_{t'} \times S_\Lambda \to S_t \).
Also let us have bad states (\Cref{def:fpt_bad_states})
\( \mathcal{B} \subseteq S_{t'} \times S_\Lambda \).
%
With that, we can use slightly adapted \Cref{lemma:fpt_join_node}
from \JoinNode{}.

% Vertices \( u, v \in X_t \) share the same \( \blue \) component if either:
% %
% \begin{itemize}
% 	\item They shared the same component in \( s' \).
% 	\item There is a \( \blue \) path in \( F \) with coloring \( \lambda \).
% \end{itemize}
% %
% Note that \( \blue \) components created by following this procedure
% are same as in \( s' \) or merged \( \blue \) components of \( s' \)
% except for \( v \) as it is not yet in \( X_{t'} \).
% Such \( \blue \) components are neighboring if either:
% %
% \begin{itemize}
% 	\item They or their predecessors in \( s' \)
% 	      were neighbors in \( s' \).
% 	\item There is a path in \( F \) with
% 	      one \( \blue \) and one \( \red \) edge
% 	      according to coloring \( \lambda \).
% 	      The \( \red \) edge becomes a connector.
% \end{itemize}
% %
% Now the same is done for \( \red \).
% We ensure that all the rules described in \IntroduceEdgeNode{}
% still hold for \( s \). If so, \( c[t, s] \pluseq c[t', s'] \).
% This all is done for each combination in \( S' \time \Lambda \).

In the original algorithm for each \( v \),
\IntroduceEdgeNode{} is used \( |F| \) times
and \( \IntroduceVertexNode{} \) once, therefore added complexity for \( v \)
is \( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot (|F| + 1) = {k}^{O(k)} \cdot 2^{O(k^2)} \cdot O(k) \).
%
For \IntroduceVertexWithEdgesNode{},
we used the same technique as for \JoinNode{}.
The complexity is lower as \( |S_\Lambda| = 2^{|F|} \) and \( |F| = O(k) \).
The runtime complexity added for \( v \) is therefore
\( {k}^{O(k)} \cdot 2^{O(k^2)} \cdot 2^{O(k)} = {k}^{O(k)} \cdot 2^{O(k^2)}\).

Both approaches are asymptotically equivalent,
it remains to be seen which yields faster runtime complexity in practice.



\subsection{NAC-coloring certificate}

To obtain a NAC-coloring certificate or all the NAC-colorings of a graph
one approach is to traverse \( T \) top-down
and track where there are positive additions to the cache function.
%
The only step where edges are introduced is \IntroduceEdgeNode{}
(or \IntroduceVertexWithEdgesNode{}).
We check if the edge is w.l.o.g.\ \( \blue \) by checking if \( c_\blue[t,s] > 0 \),
setting the edge color to blue and color remaining edges in \( G_{t'} \) recursively.
If we stop at the first NAC-coloring, we found a certificate in time bounded by
the size of \( T \)
(if we stored metadata about contributing states in the bottom-up traversal).
%
When we continue, we can obtain all NAC-colorings.
As there can be exponentially many of them,
listing all NAC-colorings is not parameterized by \( k \) anymore.
Note that the whole cache has to be stored in memory
the whole time for this approach.

Another approach is to store an almost NAC-coloring on \( G_t \)
for each \( s \in S_t, t \in T \) where \( c[t, s] > 0 \)
while preferring colorings that are not monochromatic.
The runtime performance of the algorithm degrades,
but the whole cache does not need to be stored in memory the whole time.
Only a single certificate can be obtained with this method.


%

% It is most probably true that monochromatic classes can be used
% to reduce the search space.
% The statement bellow need to be formalized better
% and more refactoring for the cache function is needed as
% now it would show the lower-bound of the number of almost NAC-colorings
% that are a restriction of an NAC-coloring on \( G \).
%
% Monochromatic classes can be used to significantly reduce the state space
% that needs to be searched as sometimes we can say that
% \( c[t, s] = 0 \) for some \( s \in S_t, t \in T \)
% without solving corresponding sub-problems.
% %
% We extend the result for monochromatic classes as follows:
% see that this is just a generalization of the previous theorem
% as an edge forms a trivial monochromatic class.
% %
% \begin{lemma}
% 	Let us have \( t \in T \),
% 	edges \( F \subseteq Y_t \) such that
% 	they share the same monochromatic class and form a connected component.
% 	Let us have vertices \( U = \{ u \mid \exists f \in F : u \in f \} \).
% 	If for a state \( s = (P_\red, R_\red, P_\blue, R_\blue) \in S \)
% 	it holds that
% 	\( {\forall a \in \{\red, \blue\} }:{ \forall p_a \in P_a }:{ U \not\subset p_a} \),
% 	then it also holds that \( c[t, s] = 0 \).
% \end{lemma}
% %
% \begin{proof}
% 	For contradiction suppose that such state is consistent with
% 	an almost NAC-coloring \( \delta \) on \( G_t \).
% 	The edges \( F \) has to be either \( \red \) or \( \blue \).
% 	Let w.l.o.g.\ edges in \( F \) be colored \( \blue \).
% 	That means that all vertices in \( U \) are in the same \( \blue \) component (and part)
% 	as the edges are from a monochromatic class.
% 	But the state \( s \) states that there is a vertex \( u \in U \)
% 	that does not share a \( \blue \) component with the other vertices in \( U \).
% 	Then \( \delta \) is not consistent with state \( s \).
% 	This is a contradiction.
% \end{proof}
% %

% Lastly, we show how \IntroduceVertexWithEdgesNode{} can be optimized.
% Colorings of \( F \) that do no match with known monochromatic classes
% are removed from \( \Lambda \). This also decreases the size of \( S_\Lambda \).

% We can extend this idea further by extracting colors of edges from \( Y_{t} \)
% based on \( s_t \in S_t \).
% For example, if the edge in \( Y_{t} \) lies in a \( \blue \) part,
% it must be colored blue and hence
% the other edges from the same monochromatic class
% must be also colored blue \( \blue \).


\subsection{Connectivity}

Along with the cache, we can also hold an information about connectivity of
vertices in bags.
%
\begin{definition}[Connectivity map]
	Let \( t \in T \) be a node in a nice tree decomposition tree and
	\( X_t \) be a bag of vertices.
	A \emph{connectivity map} \( C_t \) is a partition of \( X_t \) such that
	for each \( u, v \in X_t \), it holds that
	\( \exists c_t \in C_t : u \in c_t \land v \in c_t \) if and only if
	\( u, v \) are in the same component in \( G_t \).
\end{definition}
%

In \Cref{lemma:fpt_merging_map}, we show how to merge
two halves of two states. Let us by \( M': S_t \to \mathcal{F}(X_t) \) denote
the operation of merging halves of a single state by the same means,
obtaining a partition of \( X_t \) and dropping
the neighboring relation as we do not need it
(it holds that it is empty).
%
\begin{lemma}
	Let us have \( s \in S_t \) with connectivity map \( C_t \).
	If \( M'(s) \ne C_t \), then \( c[t, s] = 0 \).
\end{lemma}
%
\begin{proof}
	For contradiction, suppose that such state \( s \)
	is consistent with an almost NAC-coloring \( \delta \).
	%
	For each \( c_1, c_2 \in C_t, c_1 \ne c_2, u \in c_1, v \in c_2 \)
	there is no \( u \)--\( v \)--path in \( G_t \).
	Then there is also no path in the merged parts as
	they are merged along a path in~\Cref{lemma:fpt_merging_map}.
	%
	The same argument with the path non-existence
	holds also in the other direction.
\end{proof}
%
We show which conditions hold for a connectivity map
for different types of neighboring nodes.
%
For an \IntroduceVertexNode{}~\( t \) with child \( t' \), it holds that
\( C_t = C_{t'} \cup \{\{ v \}\} \).
%
For a \ForgetVertexNode{}~\( t \) with child \( t' \), it holds that
\( C_t = D(C_{t'}) \)
where \( D \) is a map from \Cref{lemma:fpt_forget_vertex_node}
deleting occurrences of the forgotten vertex from the partition given.
%
For an \IntroduceEdgeNode{}~\( t \) with child \( t' \)
where edge \( \{u, v\} \) is introduced,
if in \( C_{t'} \) vertices \( u, v \) are in the same part, \( C_t = C_{t'} \).
Otherwise, \( u, v \) are in parts \( p_1', p_2' \), then
\( C_t \cup \{p_1', p_2'\} = C_{t'} \cup \{ p_1' \cup p_2'\} \).
%
For a \JoinNode{}~\( t \) with children \( t_1', t_2' \),
connectivity maps \( C_{t_1'}, C_{t_2'} \) are merged into
a single connectivity map \( C_t \)
the same way as when a \JoinNode{} is processed using merging map \( M \).
%
For a \LeafNode{}~\( t \),
no vertices are present yet, so for the connectivity map it holds that \( C_t = \emptyset \).


\subsection{Other optimizations}

We first introduce a state space reduction for edges from edge bags.
%
Note that the following optimizations can be only used in \IntroduceEdgeNode{}
as the other nodes have empty edge bags by definition.
%
\begin{lemma}
	Let us have \( t \in T \) and an edge \( e = \{u, v\} \in Y_t \).
	If for a state \( s = (P_\red, R_\red, P_\blue, R_\blue) \in S_t \)
	it holds that
	\( {\forall a \in \{\red, \blue\}} : {\forall p_a \in P_a} : {u \in p_a \Rightarrow v \not\in p_a} \),
	then it also holds that \( c[t, s] = 0 \).
\end{lemma}
%
The lemma states that vertices \( u, v \) incident to an edge must
be share \( \red \) or \( \blue \) part.
%
\begin{proof}
	For contradiction, suppose that such state is consistent
	with some almost NAC-coloring \( \delta \) on \( G_t \).
	The edge \( e \) has to be either \( \red \) or \( \blue \).
	Let \( e \) be colored w.l.o.g.\ \( \blue \).
	That means that both \( u, v \) are in the same \( \blue \) component.
	But the state \( s \) states that \( u, v \) do not share a \( \blue \) component.
	Then \( \delta \) is not consistent with state \( s \).
	This is a contradiction.
\end{proof}

As discussed before, if the input graph has an articulation,
we can once again run our algorithm on each block of the graph separately
and then multiply the results together to get the final result
while also considering monochromatic colorings of each block.
Note that the same can be done for disconnected graphs.

There is possibility that the algorithm can be further improved by creating
a Monte Carlo algorithm or a linear algebra based algorithm that can run
in \( O(c^k), c \in \N \) time as~\cite{book_parametrized_algorithms} suggests
for problems with connectivity requirements.
Monte Carlo algorithms are randomized algorithms whole output may be incorrect
with some probability. As they are often faster, they are run many times
to obtain trustworthy results.
This is unfortunately far beyond the scope of this thesis.

