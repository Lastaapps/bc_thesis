
\chapter{Implementation}%
\label{chapter:impl}

\begin{chapterabstract}

	In this chapter, we first describe the structure of the project
	and discuss some design choices.
	\todo[inline]{Dopsat abstrakt kapitoly}

\end{chapterabstract}

In this section we first describe the structure of the project containing
the code of the algorithm.
Next, we mention libraries, relation to PyRigi and
some worth mentioning implementation details.
The code is available as an attachment of this thesis,
nevertheless the most recent version can be found on GitHub~\cite{my_code}.

The code is written in Python~\cite{python}, minimal supported version is Python 3.12.
To set up the project, create a virtual environment and install packages
from \texttt{requirements.txt}. On NixOS, \texttt{shell.nix} can be used.
See \texttt{README.md} for additional instructions.
We go through the main folders and files of the project,
to see the code structure in~\Cref{chapter:attachments}.

The base directory contains tooling for running, visualizing and exporting benchmarks.
File \texttt{NAC\_playground.ipynb} presents a simple case
to show how the algorithm's API can be used.
File \texttt{NAC\_presentation.ipynb} shows how the benchmarks can be run and analyzed.

The code of the algorithm described in~\Cref{sec:stable_cuts_implementation}
with additional helper functions is implemented in directory \texttt{stablecut}.
Note that some changes were done when the code was merged into PyRigi.

The code of the algorithms described in~\Cref{chapter:algo}
is stored in directory \texttt{nac}.
%
Directory \texttt{nac/util} stores helper functions and classes
like an implementation of the \textsc{UnionFind} data structure.
%
File \texttt{check.py} implements \IsNACColoring{} check.
%
File \texttt{monochromatic\_classes.py} is used to find \trcon{} components
and monochromatic classes in a graph. With this, we can compare performance
between using monochromatic classes, \trcon{} components or just edges.
%
File \texttt{cycle\_detection.py} holds algorithms for finding cycles
used by \Cref{sec:small_cycles}
and some heuristics.
%
In \Cref{sec:polynomial_optimizations}
we presented checks that can in polynomial time
sometimes find a NAC-coloring or determine that there is none.
These checks are implemented in \texttt{existence.py} and
used mostly from \texttt{single.py} that is the entry-point
for a single NAC-coloring search.
%
General NAC-coloring searching is implemented in \texttt{search.py}
along with parameter parsing, graph vertices normalization and
optimizations like search for articulation vertices.
After that, the correct algorithm from \Naive{}, \NaiveCycles{} or \Subgraphs{}
is chosen and called.
%
These algorithms are implemented in \texttt{algorithms.py} alongside many helper functions.
Heuristics for \Subgraphs{} algorithm are stored in \texttt{strategies.py}.
%
Tests of both stable cuts and NAC-coloring parts are stored in directory \texttt{test}.

Common function parameters are:
\texttt{graph} repressing the subgraph where NAC-colorings should be found.
%
\texttt{comp\_graph} is a graph where vertices are some integer IDs of monochromatic classes
and edges exist if the classes are neighboring,
see \Cref{observ:monochromatic_classes_graph}.
%
Monochromatic class IDs also serve as indices into \texttt{component\_to\_edges}
that maps an ID of a monochromatic class to its edges.
%
NAC-colorings are represented as bit-masks where bit's offset correspond to a class ID\@.

In \texttt{graphs\_store} we store datasets used for benchmarking.
Graphs are either obtained from~\cite{extremal_graphs},
generated using Nauty~\cite{nauty} with a plugin~\cite{nauty_plugin}
or generated using NetworkX~\cite{networkx} and checks from PyRigi~\cite{pyrigi}.
Graph are mostly stored in Graph6 format~\cite{graph6}.
Code for reading graphs from the store can be found in \texttt{benchmarks/dataset.py},
code for generating some graph classes can be found in  \texttt{benchmarks/generators.py}.
In the \texttt{benchmark/precomputed} directory, there are all result of the benchmarks that
we use for algorithms evaluation.
Individual runs are stored in a compressed CSV file.

As \IsNACColoring{} is a core component of all our algorithms,
we tried to optimized it well.
%
In the base implementation of \IsNACColoring{},
subgraphs from \( \red \) and \( \blue \) edges are created.
To create such subgraphs in code, edges can be added to an empty graph
using NetworkX's function \texttt{add\_edges\_from}.
%
This is rather slow as creating new vertices in the empty graph causes noticeable overhead.
Therefore, we create a graph with no edges and the same vertices as the original graph,
cache it and reuse it for the checks.
Every time only edges are added, the check is run, and the edges are removed.
By doing this, the performance of \IsNACColoring{} is increased by roughly 40\%.
%
Another way how the performance could be increased is by reserving space in lists
when the final size is known.
To our knowledge, this is impossible in Python.

The code uses \texttt{Graph} class and related algorithms from NetworkX~\cite{networkx}
as the base of many operations. We use some utility functions from PyRigi~\cite{pyrigi}
related to (global) rigidity tests and rigidity components search.
Other than that, the code is not dependent on PyRigi.
%
Pytest~\cite{pytest} is used for testing and
Matplotlib~\cite{matplotlib} for visualizations.
