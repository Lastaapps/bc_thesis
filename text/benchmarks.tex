\chapter{Implementation \& Benchmarks}%
\label{chapter:benchmarks}

\begin{chapterabstract}

	In this chapter, we first describe the structure of the project
	and discuss some design choices.
	After that, we evaluate performance of the algorithms
	proposed in \Cref{chapter:alg}.
	First, we compare the high-level approaches with previous approaches and among each other,
	and then we compare heuristics with each other
	for different  graph classes.
	We show reduction both in runtime and in the number
	of \IsNACColoring{} checks performed.
	Lastly, we evaluate which strategies should be preserved.

\end{chapterabstract}

\section{Implementation}

\todo[inline]{Popsat základní API knihovny}

In this section we first describe the structure of the project containing
the code of the algorithm.
Next, we mention libraries, relation to PyRigi and
some worth mentioning implementation details.
The code is available as an attachment of this thesis,
nevertheless the most recent version can be found on GitHub~\cite{my_code}.

The code is written in Python~\cite{python}, minimal supported version is Python 3.12.
To set up the project, create a virtual environment and install packages
from \texttt{requirements.txt}. On NixOS, \texttt{shell.nix} can be used.
See \texttt{README.md} for additional instructions.
We go through the main folders and files of the project,
to see the code structure in~\Cref{chapter:attachments}.

In \texttt{graphs\_store} we store datasets used for benchmarking.
Graphs are either obtained from~\cite{extremal_graphs},
generated using Nauty~\cite{nauty} with a plugin~\cite{nauty_plugin}
or generated using NetworkX~\cite{networkx} and checks from PyRigi~\cite{pyrigi}.
Graph are mostly stored in Graph6 format~\cite{graph6}.
Code for reading graphs from the store can be found in \texttt{benchmarks/dataset.py},
code for generating some graph classes can be found in  \texttt{benchmarks/generators.py}.
In the \texttt{benchmark/precomputed} directory, there are all result of the benchmarks that
we use for algorithms evaluation.
Individual runs are stored in a compressed CSV file.
%
The base directory contains tooling for running, visualizing and exporting benchmarks.
File \texttt{NAC\_playground.ipynb} presents a simple case
to show how the algorithm's API can be used.
File \texttt{NAC\_presentation.ipynb} shows how the benchmarks can be run and analyzed.

The code of the algorithm described in~\Cref{sec:stable_cuts_implementation}
with additional helper functions is implemented in directory \texttt{stablecut}.
Note that some changes were done when the code was merged into PyRigi.

The code of the algorithms described in~\Cref{chapter:alg}
is stored in directory \texttt{nac}.
%
Directory \texttt{nac/util} stores helper functions and classes
like an implementation of the \textsc{UnionFind} data structure.
%
File \texttt{check.py} implements \IsNACColoring{} check.
%
File \texttt{monochromatic\_classes.py} is used to find \trcon{} components
and monochromatic classes in a graph. With this, we can compare performance
between using monochromatic classes, \trcon{} components or just edges.
%
File \texttt{cycle\_detection.py} holds algorithms for finding cycles
used by \Cref{sec:small_cycles}
and some heuristics.
%
In \Cref{sec:polynomial_optimizations}
we presented checks that can in polynomial time
sometimes find a NAC-coloring or determine that there is none.
These checks are implemented in \texttt{existence.py} and
used mostly from \texttt{single.py} that is the entry-point
for a single NAC-coloring search.
%
General NAC-coloring searching is implemented in \texttt{search.py}
along with parameter parsing, graph vertices normalization and
optimizations like search for articulation vertices.
After that, the correct algorithm from \Naive{}, \NaiveCycles{} or \Subgraphs{}
is chosen and called.
%
These algorithms are implemented in \texttt{algorithms.py} alongside many helper functions.
Heuristics for \Subgraphs{} algorithm are stored in \texttt{strategies.py}.
%
Tests of both stable cuts and NAC-coloring parts are stored in directory \texttt{test}.

Common function parameters are:
\texttt{graph} repressing the subgraph where NAC-colorings should be found.
%
\texttt{comp\_graph} is a graph where vertices are some integer IDs of monochromatic classes
and edges exists if the classes are neighboring,
see \Cref{observ:monochromatic_classes_graph}.
%
Monochromatic class IDs also serve as indices into \texttt{component\_to\_edges}
that maps an ID of a monochromatic class to its edges.
%
NAC-colorings are represented as bit-masks where bit's offset correspond to a class ID\@.

As \IsNACColoring{} is a core component of all our algorithms,
we tried to optimized it well.
%
In the base implementation of \IsNACColoring{},
subgraphs from \( \red \) and \( \blue \) edges are created.
To create such subgraphs in code, edges can be added to an empty graph
using NetworkX's function \textsc{add\_edges\_from}.
%
This is rather slow as creating new vertices in the empty graph causes noticeable overhead.
Therefore, we create a graph with no edges and the same vertices as the original graph,
cache it and reuse it for the checks.
Every time only edges are added, the check is run, and the edges are cleared.
By doing this, the performance of \IsNACColoring{} is increased by roughly 40\%.
%
Another way how the performance could be increased is by reserving space in lists
when the final size is known.
To our knowledge, this is impossible in Python.

The code uses \textsc{Graph} class and related algorithms from NetworkX~\cite{networkx}
as the base of many operations. We use some utility functions from PyRigi~\cite{pyrigi}
related to (global) rigidity tests and rigidity components search.
Other than that, the code is not dependent on PyRigi.
%
Pytest~\cite{pytest} is used for testing and
Matplotlib~\cite{matplotlib} for visualizations.


\section{Benchmarks}

In this section we first set meaningful targets for our benchmarks,
then we compare the performance of our algorithms with the previous implementation
and show running time and internal search optimizations for various graph classes.

The main question regarding NAC-coloring search is whether a graph has a NAC-coloring.
We usually ask the algorithm to not only answer yes, but to also provide a certificate.
%
For flexible graphs, it is often algorithmically quite simple to find a NAC-coloring,
so this question is more interesting for rigid graphs.
%
For flexible graphs, it is more interesting to ask for the number of NAC-colorings
of a graph.
Note, that for larger flexible graphs with around thirty vertices
the number of NAC-colorings is huge as it often grows exponentially.
This slows our algorithm down as just materializing and iterating exponential
number of NAC-colorings takes exponential time.
%
For such cases, the FPT algorithm described in \Cref{chapter:fpt}
could be a better fit as it does not materialize any NAC-colorings.

The graphs the algorithm works with have integer vertices (we relabel the otherwise).
We noticed that for synthetically generated graphs,
the algorithm performs slightly better compared to
the same algorithm run on the same graph with vertices randomly relabeled.
To counteract this, we tried to relabel the graphs using BFS,
but we reached no performance gains compared to the random relabeling.

Visualizations in the following sections were created by grouping data per dataset,
graph size and some specified attribute --- usually the strategies used.
%
We show mean of the running time in milliseconds or
the number of \IsNACColoring{} calls.
%
Graphs with median and third quartile can be seen in \texttt{NAC\_presentation.ipynb}.


\subsection{Improvement over previous solutions}

The benchmarks comparing our algorithm with the previous implementations
were run on Linux on a laptop with Intel i7 of the 11th generation
with CPython 3.12~\cite{cpython} and SageMath 10.4~\cite{sagemath}.
The remaining benchmarks were run a laptop with Intel i5 of the 6th generation
using CPython 3.12.
On more modern hardware, the running times could be significantly shorter.

\Cref{tab:all_min_rigid}
shows the time required for finding all the NAC-colorings
of all minimally rigid graphs with given vertex count.
%
They are generated using Nauty~\cite{nauty}
with a corresponding plugin~\cite{nauty_plugin}.
%
We show results of the implementation
in \flexrilog{}~\cite{flexrilog} using \trcon{} components
run in SageMath~\cite{sagemath}
and compare them to our implementation of the same \Naive{} algorithm
using $\triangle$-connected components
and monochromatic classes as described in \Cref{sec:NACvalid}.
Next column shows \NaiveCycles{} from \Cref{sec:small_cycles}
using monochromatic classes.
The last column is for the \NeighborsDegree{} (each initial subgraph has $k=4$ monochromatic classes)
with \MergeLinear{} merging strategy.
%
In every case, our algorithms are significantly faster than implementation in \flexrilog{}~\cite{flexrilog}.
Notice also huge advantage gained by using monochromatic classes instead of \trcon{} components.
%
\begin{table}[ht]
	\caption[Running times on graphs]{
		The time (in seconds) needed to find all NAC-colorings for all graphs with a given size. Run by us.
		\textsc{FRLG} stands for \flexrilog{}, \textsc{ND} for \NeighborsDegree{}.}%
	\label{tab:all_min_rigid}
	\vspace{0.3cm}
	\centering
	\begin{tabular}{ccccccc}
		\hline
		\,$|V(G)|$\, & \,\#graphs\, & \,FRLG\, & \,$\triangle$-comps.\, & \,monochr.\, & \,cycles\, & \,\textsc{ND}\, \\
		\hline
		% 5        & 3           & 0.007 s      & 0.002 s            & 0.001 s       & 0.001 s & 0.002 s          \\
		% 6        & 13          & 0.063 s      & 0.030 s            & 0.010 s       & 0.005 s & 0.007 s          \\
		% 7        & 70          & 0.57 s       & 0.052 s            & 0.047 s       & 0.029 s & 0.041 s          \\
		8            & 608          & 14       & 1.09                   & 0.97         & 0.36       & 0.49            \\
		9            & 7\,222       & 509      & 34                     & 29           & 5.8        & 8.6             \\
		10           & 110\,132     & 27k      & 1\,725                 & 1\,446       & 151        & 213             \\
		11           & 2\,039\,273  & -        & -                      & -            & 5\,440     & 6\,650          \\
		\hline
	\end{tabular}
\end{table}

\Cref{fig:graph_time_minimally_rigid}
shows timings to compute all NAC-colorings of minimally rigid graphs
depending on the strategy used.
We did not list all NAC-coloring for all minimally rigid graphs with more than twelve vertices
as there is too many such graphs (around 44 millions for twelve vertices).
%
We rather randomly generated dataset of minimally rigid graphs
using NetworkX~\cite{networkx} and PyRigi~\cite{pyrigi}.
%
It can be seen that for graphs up to around fourteen vertices the \NaiveCycles{} algorithm
is still faster than \Subgraphs{}.
For graphs with more than eighteen vertices,
the growing advantage of \Subgraphs{} is already clear.
\Subgraphs{} can list all NAC-colorings on 30 monochromatic class graph in a few seconds.
This corresponds to \( 2^{29} \) checks done by \NaiveCycles{}.

\begin{figure}[ht]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_minimally_rigid_random_all_monochromatic_runtime_split_merging_mean.pgf}}
	\caption[Running time for minimally rigid graphs]{
		Mean running time to find all NAC-colorings for minimally rigid graphs.}%
	\label{fig:graph_time_minimally_rigid}
\end{figure}%

If we analyze the number of \IsNACColoring{} calls performed by \NaiveCycles{} and \Subgraphs{} algorithms
as shown in \Cref{fig:graph_count_minimally_rigid},
it can be seen that the number of \IsNACColoring{} calls is reduced already for graphs
with eleven vertices,
even though the \NaiveCycles{} algorithm is still faster for these graphs.
%
We think that the slowdown is caused by internal overhead
used for subgraphs splitting and merging.

\todo[inline]{Podívat se, co se kurňa děje - all vs some}
\begin{figure}[ht]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_minimally_rigid_random_all_monochromatic_checks_split_merging_mean.pgf}}
	\caption[Checks performed for minimally rigid graphs]{
		The number of checks performed to find all NAC-colorings for minimally rigid graphs.}%
	\label{fig:graph_count_minimally_rigid}
\end{figure}%

In \Cref{fig:graph_summary}
we show the relation between the number of \IsNACColoring{} checks that
would \Naive{} algorithm perform compared to our solution.
%
The values are similar for graphs with few monochromatic classes,
which explains why the \NaiveCycles{} algorithm outperformed
the \NeighborsDegree{}\&\MergeLinear{} algorithm in \Cref{tab:all_min_rigid}. This should improve quickly for larger graphs.
We can also see how the use of \CycleMask{} routine
reduces the number of more expensive \IsNACColoring{} calls,
since these are called only when the small cycles check \CycleMask{} fails to decide
(\CycleMask{} is called every time).

\begin{figure}[ht]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_check-comparision_exp_edge_no_monochromatic_checks_checks_mean.pgf}}
	\caption[The number of \IsNACColoring{} calls]{
		The number of \IsNACColoring{} calls with respect to the number of monochromatic classes
		over all graphs used for benchmarking.}%
	\label{fig:graph_summary}
\end{figure}%



\subsection{Performance on specific graph classes}%
\label{sec:bench_graph_classes}

\todo[inline]{Consider Laman deg 3+}
\todo[inline]{Consider line graphs of 3 nor 4 cycles}

Each benchmark was run two or three times and the mean was taken.
The graphs are grouped either by the number of vertices
monochromatic classes or \trcon{} components, see respective \(x\)-axis.
Overall, over 350k configurations (strategies and size of subgraphs combinations)
are presented (and 200k more were run for strategies not worth mentioning)
on over 12.8k graphs from multiple graph classes.
%
We tested only graphs with up to one hundred vertices
as it is computationally hard to find larger graphs in the classes given
and to run enough benchmarks for them
\todo{Uncomment footnote}
% \footnote{
{
	If it takes 250 milliseconds to find a NAC-coloring of a graph,
	in benchmarks, the configuration is run twice over often tens of strategies.
	The time grows quickly over a second per graph.
	If hundreds of graphs are benchmarked,
	the total running time is large.
	See our electric bill.
}.
A NAC-coloring can be found for these graphs in hundreds of milliseconds or seconds at most.

First, we only show strategies that performed well generally,
we show the others later in \Cref{sec:failing_strategies}.
If a configuration did not finish in the given time limit,
we replace the runtime field with the limit of the benchmark, usually 5 seconds.
These runs are excluded from figures with the number of check calls.


\subsubsection*{Minimally rigid graphs}

In the previous section, we showed performance of the algorithm for listing
all NAC-colorings of minimally rigid graphs,
but did not compare the strategies among each other.
%
\Neighbors{} and \NeighborsDegree{} perform slightly better than \None{} and
\SharedVertices{} outperforms \MergeLinear{} slightly.
The same also holds for the number of \IsNACColoring{} checks.
Notice that the runtime grows exponentially, but with lower factor than \NaiveCycles{}.
The growth is expected as the number of NAC-coloring grows fast.

In \Cref{fig:graph_minimally_rigid_first_runtime,fig:graph_minimally_rigid_first_checks}
we focus of finding some NAC-coloring of minimally rigid graphs.
%
Minimally rigid graphs as mostly flexible graphs have
large number of NAC-colorings, therefore it is simple for both \NaiveCycles{}
and \Subgraphs{} algorithms to find some NAC-coloring.
%
It can be seen from the graphs, that for larger graphs, the required runtime
does not grow significantly.
%
Note that minimally rigid graphs have no NAC-coloring if and only if they are formed from
a single \trcon{} component (resp. they are a 2-tree, recall \Cref{lemma:stable_cut_or_2_tree}).
Therefore, such instances do not worsen runtime performance as they are resolved instantly.
%
\NaiveCycles{} is faster as it has lower internal overhead.
The number of \IsNACColoring{} checks is also lower,
that is probably because \Subgraphs{} strategies do additional checks
while merging, which are not needed for \NaiveCycles{}.
\SharedVertices{} behaves unpredictably while \MergeLinear{} is consistent
for both the runtime and the number of \IsNACColoring{} checks.

\begin{figure}[thbp]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_minimally_rigid_random_first_monochromatic_runtime_split_merging_mean.pgf}}
	\caption[Mean runtime for minimally rigid graphs (some)]{
		Mean running time to find all NAC-colorings for minimally rigid graphs.}%
	\label{fig:graph_minimally_rigid_first_runtime}
\end{figure}%
\begin{figure}[thbp]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_minimally_rigid_random_first_monochromatic_checks_split_merging_mean.pgf}}
	\caption[Checks performed for minimally rigid graphs (some)]{
		The number of checks performed to find all NAC-colorings for minimally rigid graphs.}%
	\label{fig:graph_minimally_rigid_first_checks}
\end{figure}%



\subsubsection*{No three nor four cycle graphs}

From~\cite{extremal_graphs} we obtained all graphs with up to 52 vertices
that have no three nor four cycles. This class of graphs is interesting for us
as there cannot be any \trcon{} components.
These graphs have also many NAC-colorings.
Because of that, as seen in \Cref{fig:graph_count_no_3_nor_4_cycles_first_runtime},
\NaiveCycles{} is again faster for finding some NAC-coloring
for the similar reasons as for minimally rigid graphs.
%
Also notice that \SharedVertices{} performs worse and non-deterministically
for \CyclesMatchChunks{} and \None{}.
For \Neighbors{}, the performance is more stable, but still worse than \MergeLinear{}.

\begin{figure}[thbp]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_no_3_nor_4_cycles_first_monochromatic_runtime_split_merging_mean.pgf}}
	\caption[Mean runtime for graphs with no 3 nor 4 cycles (some)]{
		Mean running time to find all NAC-colorings for graphs with no three nor four cycles.}%
	\label{fig:graph_count_no_3_nor_4_cycles_first_runtime}
\end{figure}%
% \begin{figure}[thbp]
% 	\centering
% 	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_no_3_nor_4_cycles_first_monochromatic_checks_split_merging_mean.pgf}}
% 	\caption[Checks performed for graphs with no 3 nor 4 cycles (some)]{
% 		The number of checks performed to find all NAC-colorings for graphs with no three nor four cycles.}%
% 	\label{fig:graph_count_no_3_nor_4_cycles_first_checks}
% \end{figure}%

For listing all NAC-colorings shown
in \Cref{fig:graph_count_no_3_nor_4_cycles_all_runtime}
shows that \NaiveCycles{} is almost never faster.
We can see that \None{} and \CyclesMatchChunks{} is also slower than
\Neighbors{} and \NeighborsDegree{}.
At around twenty-eight vertices five second time limit is reached for all algorithms.
\MergeLinear{} and \SharedVertices{} have no significant influence.
%
\begin{figure}[thbp]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_no_3_nor_4_cycles_all_monochromatic_runtime_split_merging_mean.pgf}}
	\caption[Mean runtime for graphs with no 3 nor 4 cycles (all)]{
		Mean running time to find all NAC-colorings for graphs with no three nor four cycles.}%
	\label{fig:graph_count_no_3_nor_4_cycles_all_runtime}
\end{figure}%
% \begin{figure}[thbp]
% 	\centering
% 	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_no_3_nor_4_cycles_all_monochromatic_checks_split_merging_mean.pgf}}
% 	\caption[Checks performed for graphs with no 3 nor 4 cycles (all)]{
% 		The number of checks performed to find all NAC-colorings for graphs with no three nor four cycles.}%
% 	\label{fig:graph_count_no_3_nor_4_cycles_all_checks}
% \end{figure}%


\subsubsection*{Globally rigid graphs}

We also randomly generated a dataset of globally rigid graphs
up to 57 vertices.
We used a formula from yet unpublished work of John Haslegrave
that for a number of vertices gives a number of edges,
such that graphs have no or just a few NAC-colorings.
For such random graphs, we checked if they are globally rigid using PyRigi~\cite{pyrigi}.
%
The idea of monochromatic classes is so effective
that even large graphs collapse into just a few monochromatic classes.
Majority of the graphs in this dataset either has a NAC-coloring,
or only a single monochromatic class and therefore no NAC-coloring.
In our dataset, 75 percent of graphs have less than ten	monochromatic classes,
but only 10 percent of graphs have less than ten \trcon{} components
as you can see in \Cref{fig:monochrom_vs_triangle_globally_rigid}.
For minimally rigid graphs, this is not the case as expected, see
\Cref{fig:monochrom_vs_triangle_minimally_rigid}.
%
\begin{figure}[h!]
	\centering
	\begin{subfigure}{0.48\textwidth}
		\centering
		\scalebox{0.6}{\input{./figures/monochromatic_vs_triangle_globally_rigid.pgf}}
		\caption[Monoch. classes vs tr. con. components for globally rigid]{%
			\centering Globally rigid graphs}%
		\label{fig:monochrom_vs_triangle_globally_rigid}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.48\textwidth}
		\centering
		\scalebox{0.6}{\input{./figures/monochromatic_vs_triangle_minimally_rigid_random.pgf}}
		\caption[Monoch. classes vs tr. con. components for minimally rigid]{%
			\centering Minimally rigid graphs}%
		\label{fig:monochrom_vs_triangle_minimally_rigid}
	\end{subfigure}
	\caption{Monochromatic classes vs \trcon{} components}%
	\label{fig:monochrom_vs_triangle}
\end{figure}

\NaiveCycles{} is no longer faster for finding a NAC-coloring
as shown in \Cref{fig:graph_globally_rigid_first_runtime}.
\None{} and \Neighbors{} strategies match the performance and
the other are not far behind.
%
\begin{figure}[thbp]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_globally_rigid_first_vertex_runtime_split_merging_mean.pgf}}
	\caption[Mean runtime for globally rigid graphs (some)]{
		Mean running time to find some NAC-colorings for globally rigid graphs.}%
	\label{fig:graph_globally_rigid_first_runtime}
\end{figure}%
% \begin{figure}[thbp]
% 	\centering
% 	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_globally_rigid_first_monochromatic_checks_split_merging_mean.pgf}}
% 	\caption[Checks performed for globally rigid graphs (some)]{
% 		The number of checks performed to find some NAC-colorings for globally rigid graphs.}%
% 	\label{fig:graph_globally_rigid_first_checks}
% \end{figure}%

\NaiveCycles{} is significantly slower when we list all NAC-colorings
as expected, see \Cref{fig:graph_globally_rigid_all_runtime}.
\None{} and \CycleMask{} strategies also lack behind \Neighbors{} and \NeighborsDegree{}.
We do not see a advantage of \MergeLinear{} over \SharedVertices{} any more.
%
It can be also seen in \Cref{fig:graph_globally_rigid_all_checks}
that for the number of checks performed the same statements hold.
%
\begin{figure}[thbp]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_globally_rigid_all_monochromatic_runtime_split_merging_mean.pgf}}
	\caption[Mean runtime for globally rigid graphs (all)]{
		Mean running time to find all NAC-colorings for globally rigid graphs.}%
	\label{fig:graph_globally_rigid_all_runtime}
\end{figure}%
\begin{figure}[thbp]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_globally_rigid_all_monochromatic_checks_split_merging_mean.pgf}}
	\caption[Checks performed for globally rigid graphs (all)]{
		The number of checks performed to find all NAC-colorings for globally rigid graphs.}%
	\label{fig:graph_globally_rigid_all_checks}
\end{figure}%



\subsubsection*{Summary}
\todo[inline]{Je tohle vůbec třeba? Plus je to takové divné, když se globally chovají jinak.}

To summarize this section, we mostly tested graphs having many NAC-colorings
or trivially having none.
The only exception were some globally rigid graphs.
%
Overall, if only a single NAC-coloring is requested
for these graph classes, you can notice that the complexity
is not growing fast neither for the \NaiveCycles{} nor for \Subgraphs{}.

From figures above, we can see that both algorithms should scale well for larger graphs.
For finding a single NAC-coloring, \Subgraphs{} are outperformed or matched by \NaiveCycles{}.
For listing all NAC-colorings, the \NaiveCycles{} algorithm
is not suitable even for small graphs.

It can be also seen that \MergeLinear{} is the most reliable one
while the \SharedVertices{} sometimes performs slightly better,
but sometimes behave non-deterministically, mostly for easy instances.
%
Splitting strategies \None{}, \Neighbors{} and \NeighborsDegree{}
performs similarly.


\subsection{Performance on graphs with no NAC-colorings}

In the previous section, the \Subgraphs{} algorithm
often performed worse considering runtime.
As explained, it is caused by the graphs being too simple
--- having plenty of NAC-colorings.
%
For many NP-complete problems, studied instances are often
those where there are only few or no solutions.
In this section, we focus on graphs with no NAC-colorings.

We searched for random graphs where \( |E| \ge 2|V(G)| - 2 \) that have
multiple monochromatic classes, but no NAC-coloring
\todo{Uncoment footnote}
% \footnote{
{We could have also used the same formula as for globally rigid graphs.}.
%
As this graph generation was slow and unsuccessful, we searched only for
graphs with more than \( 2\sqrt{|V(G)|} \) \trcon{} components.
%
This once again shows how effective monochromatic classes are
in comparison with \trcon{} components.
We generated and tested five thousand of such graphs from 40 to 130 vertices in size.
Just one of them had more than one monochromatic class
\todo{Footnote}
{We also found around fifteen globally rigid graphs with this property.}.
%
The following benchmarks are run with monochromatic classes disabled.

For these graphs, \NaiveCycles{} algorithm needs to traverse all \( 2^{t-1} \)
where \( t \) is the number of \trcon{} components. It can be clearly seen that
this is not suitable for graphs as large as we use in this benchmark,
therefore, they are not present as they did not finish in reasonable time.
It can be seen from \Cref{fig:graph_no_nac_coloring_first_runtime}
that \SharedVertices{} is faster than \MergeLinear{},
for runtime and also for the number of checks performed
as shown in \Cref{fig:graph_no_nac_coloring_first_checks}.
%
It can be also seen that \NeighborsDegree{} strategy is
faster than the other strategies, and it holds for both merging strategies.
Also notice that,
runtime grows strictly exponentially.
This is in contrast with the previous section
as these graphs are not simple anymore.

\begin{figure}[thbp]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_no_nac_coloring_generated_first_triangle_runtime_split_merging_mean.pgf}}
	\caption[Mean runtime for graphs with no NAC-coloring]{
		Mean running time to find all NAC-colorings for graphs with no NAC-coloring.}%
	\label{fig:graph_no_nac_coloring_first_runtime}
\end{figure}%
\begin{figure}[thbp]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_no_nac_coloring_generated_first_triangle_checks_split_merging_mean.pgf}}
	\caption[Checks performed for graphs with no NAC-coloring]{
		The number of checks performed to find all NAC-colorings for graphs with no NAC-coloring.}%
	\label{fig:graph_no_nac_coloring_first_checks}
\end{figure}%

In \Subgraphs{} algorithm description, an important parameter was the size of subgraphs \( k \).
Majority of the benchmarks in the previous section were run with \( k = 4 \).
%
We show the impact of	\( k \) on runtime and number of checks.
Note that you see averages over all the strategies used for benchmarking
graphs with no NAC-colorings.
%
From graphs in \Cref{fig:graph_no_nac_coloring_first_runtime_subgraph_size,fig:graph_no_nac_coloring_first_checks_subgraph_size},
it can be seen that the number of checks is reduced for smaller \( k \).
On the other hand, the runtime improves slightly for larger \( k \)
and becomes negligible for larger graphs.

\begin{figure}[thbp]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_no_nac_coloring_generated_first_triangle_runtime_subgraph_size_mean.pgf}}
	\caption[Mean runtime for graphs with no NAC-coloring]{
		Mean running time to find all NAC-colorings for graphs with no NAC-coloring for different subgraph sizes \( k \).}%
	\label{fig:graph_no_nac_coloring_first_runtime_subgraph_size}
\end{figure}%
\begin{figure}[thbp]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_no_nac_coloring_generated_first_triangle_checks_subgraph_size_mean.pgf}}
	\caption[Checks performed for graphs with no NAC-coloring]{
		The number of checks performed to find all NAC-colorings for graphs with no NAC-coloring for different subgraph sizes \( k \).}%
	\label{fig:graph_no_nac_coloring_first_checks_subgraph_size}
\end{figure}%


\todo[inline]{Failing -> Other}

\subsection{Failing strategies}%
\label{sec:failing_strategies}

In this section, we show the performance of other strategies described in \Cref{chapter:alg}.
We do not show these strategies in previous figures as they would influence
the scale and would make figures and legends unreadable and unclear.

Some of these strategies perform as well as
than our preferred strategies for some graph classes,
but fail for others and therefore are not universal enough to use in a library.
%
In the following figures, we fixed
split strategy to \Neighbors{} or merging strategy to \MergeLinear{}
as they perform the best as shown in \Cref{sec:bench_graph_classes}.

First, we show in \Cref{fig:graph_mimimally_rigid_failing_merging_first_runtime,fig:graph_no_nac_coloring_generated_rigid_failing_merging_first_runtime}
how strategies like \Log{} and \PromisingCycles{} fail on minimally rigid graphs.
We also shown in \Cref{fig:graph_mimimally_rigid_failing_split_first_runtime},
\KernighanLin{} and \Cuts{} perform worse.
%
Graphs with no three nor four cycles behave similarly for these strategies.
%
\begin{figure}[thbp]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_minimally_rigid_random_failing_merging_first_vertex_runtime_split_merging_mean.pgf}}
	\caption[Failing merging strategies for minimally rigid graphs]{
		Mean running time to find all NAC-colorings for minimally rigid graphs with failing merging strategies.}%
	\label{fig:graph_mimimally_rigid_failing_merging_first_runtime}
\end{figure}%
\begin{figure}[thbp]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_minimally_rigid_random_failing_split_first_vertex_runtime_split_merging_mean.pgf}}
	\caption[Failing splitting strategies for minimally rigid graphs]{
		Mean running time to find all NAC-colorings for minimally rigid graphs with failing splitting strategies.}%
	\label{fig:graph_mimimally_rigid_failing_split_first_runtime}
\end{figure}%


As shown in \Cref{fig:graph_no_nac_coloring_generated_rigid_failing_merging_first_runtime},
strategies \Log{}, \SortedBits{} and \MinMax{} fail,
\PromisingCycles{} perform well on the other hand.
%
It can be seen that strategies \SortedSize{} and \Score{} perform
as well as our preferred strategies on graphs with no NAC-coloring.
But as they must list all the NAC-colorings on each subgraph,
they are not suitable for cases where only one NAC-coloring is requested.
%
In \Cref{fig:graph_no_nac_coloring_generated_rigid_failing_split_first_runtime}
it can be seen that performance of \KernighanLin{} and \Cuts{} is worse.
%
\begin{figure}[thbp]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_no_nac_coloring_generated_failing_merging_first_triangle_runtime_split_merging_mean.pgf}}
	\caption[Failing merging strategies for graphs with no NAC-coloring]{
		Mean running time to find all NAC-colorings for graphs with no NAC-coloring with failing merging strategies.}%
	\label{fig:graph_no_nac_coloring_generated_rigid_failing_merging_first_runtime}
\end{figure}%
\begin{figure}[thbp]
	\centering
	\scalebox{\BenchFigureScale}{\input{./figures/graph_export_no_nac_coloring_generated_failing_split_first_triangle_runtime_split_merging_mean.pgf}}
	\caption[Failing splitting strategies for graphs with no NAC-coloring]{
		Mean running time to find all NAC-colorings for graphs with no NAC-coloring with failing splitting strategies.}%
	\label{fig:graph_no_nac_coloring_generated_rigid_failing_split_first_runtime}
\end{figure}%


Smart split described in \Cref{sec:smart_split}
did not improve the runtime.
We expected minor performance hit for smaller graphs because heuristic is run
multiple times, but gains for larger graphs where subgraphs merging order
should join subgraphs near to each other together. This is not the case.

\subsection{Final comparison}

Based on our benchmarks, most of which we presented in the previous sections,
we evaluate respective strategies and choose ones
that should be kept and merged into PyRigi.
For graph classes with a lot of NAC-colorings,
\NaiveCycles{} is usually the best choice
when we search for a single NAC-coloring.
%
The user of the library has to pay attention while using this strategy
as if there is just a few or no NAC-coloring and the graph does not trivially collapse
into few monochromatic classes, the runtime is huge.
Therefore, \NaiveCycles{} should be available, but the default.

First we evaluate strategies for splitting:
Strategy \None{} works well in most of the cases and for simple
instances it outperforms other strategies as it requires little to no overhead.
%
\CyclesMatchChunks{} performed well in the majority cases simillar to \None{},
but it is generally slightly outperformed by \Neighbors{}.
%
\Neighbors{} and \NeighborsDegree{} generally managed to reduce the number
of \IsNACColoring{} calls and for complex cases they often
perform slightly better then \None{}.
Note that the implementation of \Neighbors{} is slightly simpler than
the one of \NeighborsDegree{}.
%
\KernighanLin{} results are not consistent.
\Cuts{} perform even worse for even small instance.
This is probably because they operate on a graph of monochromatic
components that does not preserver all the properties
of the original graph well.
Never they were noticeably faster than \Neighbors{}.
Therefore, these algorithms cannot be used in general case.
%
Based on this evaluation, we keep algorithms \None{} and \Neighbors{}
as they perform the best across all graph classes and
as \Neighbors{} strategy has simpler implementation.

\MergeLinear{} strategy performed the best across the board.
It seems that the idea of merging one growing subgraph
with subgraphs of initial small size works the best
in a general case.
%
For listing all NAC-colorings, \SharedVertices{} performs
slightly better, but for a search for a single NAC-coloring for simple instances,
its runtime becomes less predictable.
%
From the general idea of the \Subgraphs{} algorithm,
it makes a lot of sense \Log{} strategy would work great.
This is not the case as \Log{} is slow for all the cases we tested.
%
\MinMax{} and \SortedBits{} strategies often perform badly
and if they do not, they do not outperform other strategies.
%
\PromisingCycles{} performs similarly well as \Neighbors{}
for graphs with no NAC-coloring,
but fails for simple instances which makes it not universal enough.
%
\SortedSize{} and \Score{} also perform well for graphs with no NAC-coloring,
but as explained in \Cref{sec:merging},
they are unsuitable for instances where only a single NAC-coloring
should be found as these strategies always list all NAC-colorings
on all subgraphs.
%
Based on this evaluation, we keep strategy \MergeLinear{} as a general good choice
and also preserve \SharedVertices{} for graphs that are not simple instances.

