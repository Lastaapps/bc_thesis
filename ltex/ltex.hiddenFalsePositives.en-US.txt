{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QLaštovička Název příkladné závěrečné práce Petr Laštovička Petr Dr. techn. Ing. Jan Legerský Katedra teoretické informatiky 2021 Praze Fill in the abstract of this thesis in Czech.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QLaštovička Název příkladné závěrečné práce Petr Laštovička Petr Dr. techn. Ing. Jan Legerský Faculty of Theoretical Informatics 2025 Prague Fill in the abstract of this thesis in Czech.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QLaštovička NAC-colorings search: complexity and algorithms Petr Laštovička Petr Dr. techn. Ing. Jan Legerský Faculty of Theoretical Informatics 2025 Prague Fill in the abstract of this thesis in Czech.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QTo name a few: VertexCover, DominatingSet, LongestPath, ….\\E$"}
{"rule":"UNLIKELY_OPENING_PUNCTUATION","sentence":"^\\Q: a node \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q with one child \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q such that \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q where \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UNLIKELY_OPENING_PUNCTUATION","sentence":"^\\Q: a node \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q with two children \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q such that \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"WHOSE_DT","sentence":"^\\QThe papers \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q do not provide pseudocode to find the stable cutset (if present), they only provide list of claims from whose a stable cut set can be found.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QStable cuts, NAC-colourings and flexible realisations of graphs\\E$"}
{"rule":"WHOSE_DT","sentence":"^\\QThe papers \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q do not provide an algorithm to find the stable cutset (if present), they only provide list of claims from whose a stable cut set can be found.\\E$"}
{"rule":"WHOSE_DT","sentence":"^\\QThe papers \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q do not provide an algorithm to find the stable cutset (if present) for graphs where \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, they only provide list of claims from whose a stable cut set can be found.\\E$"}
{"rule":"WHOSE_DT","sentence":"^\\QThe papers \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q do not provide an algorithm to find the stable cut (if present) for graphs where \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, they only provide list of claims from whose a stable cut set can be found.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qvertex=[circle, draw, fill=black, inner sep=0pt, minimum size=4pt] vertexSig=[circle, draw, fill=colOrange, inner sep=0pt, minimum size=4pt] edge=[line width=1.5pt,ecol] dots=[dotted dash=1.5pt] redge=[edge,colR] bedge=[edge,colB] yedge=[edge,colOrange]\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Qvertex=[circle, draw, fill=black, inner sep=0pt, minimum size=4pt] vertexSig=[circle, draw, fill=colOrange, inner sep=0pt, minimum size=4pt] edge=[line width=1.5pt,ecol] dots=[dotted dash=1.5pt] redge=[edge,colR] bedge=[edge,colB] yedge=[edge,colOrange]\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QIntroduction to .\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QFor an where edge \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is introduced components of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q are merged if they are not merged already.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QFor an where edge \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is introduced components of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q are merged if they are not merged already.\\E$"}
{"rule":"DT_DT","sentence":"^\\QFor an a new connectivity map is obtained as follows: \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QFor a a new connectivity map is obtained as \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q where \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is mapping from the deleting occurrences of forgotten vertex from the factorization given.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QFor a no vertices are connected yet, so the connectivity map \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_BEGINNING_RULE","sentence":"^\\QFor a connectivity maps \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q are merged into a single connectivity map \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q the same way as when a is processed.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QFor a connectivity maps \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q are merged into a single connectivity map \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q the same way as when a is processed.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QConsider a node \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and its child \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q or children \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q in case of a .\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\Qstrukturální teorie tuhosti, generická flexibilita, NAC-barvení, stable-cut, parametrizovaná komplexita, NP-úplnost rigidity theory, generic flexibility, NAC-coloring, stable-cut, parametrized complexity, NP-completeness\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qstrukturální teorie tuhosti, generická flexibilita, NAC-barvení, stable-cut, parametrizovaná komplexita, NP-úplnost rigidity theory, generic flexibility, NAC-coloring, stable-cut, parametrized complexity, NP-completeness\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QWe construct the graph so that the edges with the same label have the same color in every NAC-coloring: eventually, blue edges will correspond to and red edges to .\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QFor each variable \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q we assign if the train \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is blue, otherwise .\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QNow we prove that for every truth assignment such that \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q evaluates to , there exist a NAC-coloring of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThe edges labelled \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q are blue since the \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q-th clause evaluates to .\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QAfter recalling the solution used in , we describe an improvement of the idea of components in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q and checking whether a coloring is a NAC-coloring in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThe strategy with the least overhead costs is to take the chunks of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q consecutive monochromatic classes in the input list (heuristic ).\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QWe call the following heuristic , its pseudocode is in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"POSSESSIVE_APOSTROPHE","sentence":"^\\QWe can also see how the cycles optimization reduces the number of more expensive calls, since these are called only when the small cycles check passes.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qlet the connecting edge corresponding to \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is colored \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QFirst we introduce state space reduction when there is an edge in a bag, then we extend the result to multiple edges sharing the same monochromatic component, and lastly we improve the number of operations needed in the .\\E$"}
{"rule":"WHERE_MD_VB","sentence":"^\\QLastly, we describe how can be optimized.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QA connectivity map \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q is a factorization of .\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThe only step where edges were added to the graph are either or .\\E$"}
{"rule":"GONNA","sentence":"^\\QNever Gonna Give You Up\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QFor more performant implementation it is useful if we handle all the edges at the point when both vertices incident to them are present in a bag for the first time (e.g. in the ).\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThe previous algorithm is modified by also introducing edges in and removing .\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThe same is also done for , but there are multiple such constrains\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThe same is also done for , but there are multiple such constrains checked at the same time.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QAs also described above, often FPT algorithms parametrized by tree width use variant on that also introduces edges, we call this node .\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThe previous algorithm is modified by replacing every by and introducing edges in it and removing every .\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QAs also described above, FPT algorithms parametrized by tree width often use that also introduces edges, for this section we call this node .\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThe same is also done for , but you can think of the process as multiple such constrains checked at the same time.\\E$"}
{"rule":"IT_IS","sentence":"^\\QThe core concept of Rigidity Theory is a framework which is a simple graph \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q with its a realization of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q into a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q-dimensional plane \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"IT_IS","sentence":"^\\QThe core concept of Rigidity Theory is a framework which is a simple graph \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q with its a realization of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q into a \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q-dimensional space \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"WHOSE_DT","sentence":"^\\QThe papers \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q do not provide an algorithm to find a stable cut (if present) for graphs where \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, they only provide list of claims from whose a stable cut set can be found.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qmonochromatic classes.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThe strategy with the least overhead costs is to take the chunks of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q consecutive monochromatic classes in the vertex input list (heuristic ).\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QWe start with a heuristic that we call , its pseudocode is in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"COMMA_PERIOD","sentence":"^\\Q., .\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QWe also tried approach , where Kernighan-Lin algorithm is replaced by more classical flow based edge cuts to split graph into parts.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QFollowing strategy is called .\\E$"}
{"rule":"REP_PASSIVE_VOICE","sentence":"^\\QFollowing strategy is called .\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_US","sentence":"^\\QFor a graph, many different tree decompositions can be obtained.\\E$"}
